<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xMEabf"><tr><td>xMEabf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xMEabf</h2>

<h3>Usage</h3>

<pre>
xMEabf(eqtl.summary, gwas.summary, prior.eqtl = 1e-04, prior.gwas =
1e-04, prior.both = 1e-05)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>eqtl.summary</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>gwas.summary</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>prior.eqtl</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>prior.gwas</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>prior.both</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (eqtl.summary, gwas.summary, prior.eqtl = 1e-04, prior.gwas =
1e-04,
prior.both = 1e-05)
{
if (all(c("beta", "varbeta", "N", "MAF", "snp") %in%
names(eqtl.summary))) {
oneover &lt;- 1/eqtl.summary$MAF
nvx &lt;- 2 * eqtl.summary$N * eqtl.summary$MAF * (1 - eqtl.summary$MAF)
m &lt;- stats::lm(nvx ~ oneover - 1)
cf &lt;- stats::coef(m)[["oneover"]]
if (cf &gt; 0) {
eqtl.summary$sdY &lt;- sqrt(cf)
z &lt;- eqtl.summary$beta/sqrt(eqtl.summary$varbeta)
V &lt;- eqtl.summary$varbeta
sd.prior &lt;- 0.15 * eqtl.summary$sdY
r &lt;- sd.prior^2/(sd.prior^2 + V)
lABF &lt;- 0.5 * (log(1 - r) + (r * z^2))
df_eQTL &lt;- data.frame(eqtl.V = V, eqtl.z = z, eqtl.r = r,
eqtl.lABF = lABF, snp = eqtl.summary$snp, stringsAsFactors = F)
}
else {
return(NULL)
}
}
else {
return(NULL)
}
if (all(c("beta", "varbeta", "snp") %in% names(gwas.summary))) {
z &lt;- gwas.summary$beta/sqrt(gwas.summary$varbeta)
V &lt;- gwas.summary$varbeta
sd.prior &lt;- 0.2
r &lt;- sd.prior^2/(sd.prior^2 + V)
lABF &lt;- 0.5 * (log(1 - r) + (r * z^2))
df_gwas &lt;- data.frame(gwas.V = V, gwas.z = z, gwas.r = r,
gwas.lABF = lABF, snp = gwas.summary$snp, stringsAsFactors = F)
}
else {
return(NULL)
}
merged.df &lt;- merge(df_eQTL, df_gwas)
if (nrow(merged.df) == 0) {
warnings("fail to merge df_eQTL and df_gwas. Both should contain the
common snps")
return(NULL)
}
else {
merged.df$both.sum.lABF &lt;- merged.df$eqtl.lABF + merged.df$gwas.lABF
logsum &lt;- function(x) {
max(x) + log(sum(exp(x - max(x))))
}
logdiff &lt;- function(x, y) {
max(x, y) + log(exp(x - max(x, y)) - exp(y - max(x,
y)))
}
x &lt;- merged.df$both.sum.lABF
my.denom.log.abf &lt;- logsum(x)
merged.df$SNP.PP.H4 &lt;- exp(x - my.denom.log.abf)
SNP.PP.H4 &lt;- NULL
merged.df &lt;- merged.df %&gt;% dplyr::arrange(-SNP.PP.H4)
p1 &lt;- prior.eqtl
p2 &lt;- prior.gwas
p12 &lt;- prior.both
l1 &lt;- merged.df$eqtl.lABF
l2 &lt;- merged.df$gwas.lABF
lsum &lt;- l1 + l2
lH0.abf &lt;- 0
lH1.abf &lt;- log(p1) + logsum(l1)
lH2.abf &lt;- log(p2) + logsum(l2)
lH3.abf &lt;- log(p1) + log(p2) + logdiff(logsum(l1) + logsum(l2),
logsum(lsum))
lH4.abf &lt;- log(p12) + logsum(lsum)
all.abf &lt;- c(lH0.abf, lH1.abf, lH2.abf, lH3.abf, lH4.abf)
pp.abf &lt;- exp(all.abf - logsum(all.abf))
names(pp.abf) &lt;- paste0("PP.H", (1:length(pp.abf)) -
1, ".abf")
output &lt;- list(summary = c(nsnps = nrow(merged.df), pp.abf),
results = merged.df)
invisible(output)
}
}
</pre>


</body></html>
