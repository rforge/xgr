<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGR2nGenes"><tr><td>xGR2nGenes</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGR2nGenes</h2>

<h3>Usage</h3>

<pre>
xGR2nGenes(data, format = c("chr:start-end", "data.frame", "bed",
"GRanges"), build.conversion = c(NA, "hg38.to.hg19", "hg18.to.hg19"),
distance.max = 50000, decay.kernel = c("rapid", "slow", "linear",
"constant"), decay.exponent = 2, GR.Gene = c("UCSC_knownGene",
"UCSC_knownCanonical"), scoring = F, scoring.scheme = c("max", "sum",
"sequential"), scoring.rescale = F, verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata", guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>format</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>build.conversion</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>distance.max</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>decay.kernel</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>decay.exponent</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.Gene</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>scoring</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>scoring.scheme</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>scoring.rescale</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, format = c("chr:start-end", "data.frame", "bed",
"GRanges"), build.conversion = c(NA, "hg38.to.hg19", "hg18.to.hg19"),
distance.max = 50000, decay.kernel = c("rapid", "slow", "linear",
"constant"), decay.exponent = 2, GR.Gene = c("UCSC_knownGene",
"UCSC_knownCanonical"), scoring = F, scoring.scheme = c("max",
"sum", "sequential"), scoring.rescale = F, verbose = T,
RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
format &lt;- match.arg(format)
build.conversion &lt;- match.arg(build.conversion)
decay.kernel &lt;- match.arg(decay.kernel)
scoring.scheme &lt;- match.arg(scoring.scheme)
dGR &lt;- xGR(data = data, format = format, build.conversion =
build.conversion,
verbose = verbose, RData.location = RData.location, guid = guid)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Load positional information for Genes (%s) ...",
as.character(now)), appendLF = T)
}
if (class(GR.Gene) == "GRanges") {
gr_Gene &lt;- xGR(GR.Gene, format = "GRanges", build.conversion =
build.conversion,
verbose = verbose, RData.location = RData.location,
guid = guid)
}
else {
gr_Gene &lt;- xRDataLoader(RData.customised = GR.Gene[1],
verbose = verbose, RData.location = RData.location,
guid = guid)
if (is.null(gr_Gene)) {
GR.Gene &lt;- "UCSC_knownGene"
if (verbose) {
message(sprintf("Instead, %s will be used", GR.Gene),
appendLF = T)
}
gr_Gene &lt;- xRDataLoader(RData.customised = GR.Gene,
verbose = verbose, RData.location = RData.location,
guid = guid)
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Define nearby genes (%s) ...", as.character(now)),
appendLF = T)
}
maxgap &lt;- distance.max - 1
minoverlap &lt;- 0L
subject &lt;- gr_Gene
query &lt;- dGR
q2r &lt;-
as.matrix(as.data.frame(suppressWarnings(GenomicRanges::findOverlaps(query
= query,
subject = subject, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = T))))
if (length(q2r) &gt; 0) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Calculate distance (%s) ...", as.character(now)),
appendLF = T)
}
if (1) {
x &lt;- subject[q2r[, 2], ]
y &lt;- query[q2r[, 1], ]
dists &lt;- GenomicRanges::distance(x, y, select = "all",
ignore.strand = T)
df_nGenes &lt;- data.frame(Gene = names(x), GR = names(y),
Dist = dists, stringsAsFactors = F)
}
else {
list_gene &lt;- split(x = q2r[, 1], f = q2r[, 2])
ind_gene &lt;- as.numeric(names(list_gene))
res_list &lt;- lapply(1:length(ind_gene), function(i) {
x &lt;- subject[ind_gene[i], ]
y &lt;- query[list_gene[[i]], ]
dists &lt;- GenomicRanges::distance(x, y, select = "all",
ignore.strand = T)
res &lt;- data.frame(Gene = rep(names(x), length(dists)),
GR = names(y), Dist = dists, stringsAsFactors = F)
})
df_nGenes &lt;- do.call(rbind, res_list)
}
if (distance.max == 0) {
x &lt;- df_nGenes$Dist
}
else {
x &lt;- df_nGenes$Dist/distance.max
}
if (decay.kernel == "slow") {
y &lt;- 1 - (x)^decay.exponent
}
else if (decay.kernel == "rapid") {
y &lt;- (1 - x)^decay.exponent
}
else if (decay.kernel == "linear") {
y &lt;- 1 - x
}
else {
y &lt;- 1
}
df_nGenes$Weight &lt;- y
if (verbose) {
now &lt;- Sys.time()
message(sprintf("%d Genes are defined as nearby genes within %d(bp)
genomic distance window using '%s' decay kernel (%s)",
length(unique(df_nGenes$Gene)), distance.max,
decay.kernel, as.character(now)), appendLF = T)
}
df_nGenes &lt;- df_nGenes[order(df_nGenes$Gene, df_nGenes$Dist,
decreasing = FALSE), ]
if (scoring) {
if (0) {
G2S_score &lt;- xSparseMatrix(df_nGenes[, c("Gene",
"GR", "Weight")], verbose = verbose)
}
ls_gene &lt;- split(x = df_nGenes$Weight, f = df_nGenes$Gene)
if (scoring.scheme == "max") {
seeds.genes &lt;- sapply(ls_gene, max)
if (0) {
ind &lt;- !duplicated(df_nGenes[, 1])
seeds.genes &lt;- df_nGenes[ind, 4]
names(seeds.genes) &lt;- df_nGenes[ind, 1]
system.time({
seeds.genes &lt;- apply(G2S_score, 1, function(x) {
base::max(x)
})
})
}
}
else if (scoring.scheme == "sum") {
seeds.genes &lt;- sapply(ls_gene, sum)
if (0) {
seeds.genes &lt;- base::rowSums(as.matrix(G2S_score))
seeds.genes &lt;- apply(G2S_score, 1, function(x) {
base::sum(x)
})
}
}
else if (scoring.scheme == "sequential") {
seeds.genes &lt;- sapply(ls_gene, function(x) {
base::sum(x/base::rank(-x, ties.method = "min"))
})
if (0) {
seeds.genes &lt;- apply(G2S_score, 1, function(x) {
base::sum(base::sort(x, decreasing = T)/(1:length(x)))
})
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("In summary, %d Genes are defined as seeds and scored
using '%s' scoring scheme (%s)",
length(seeds.genes), scoring.scheme, as.character(now)),
appendLF = T)
}
if (scoring.rescale) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Also rescale score into the [0,1] range (%s)",
as.character(now)), appendLF = T)
}
seeds.genes &lt;- (seeds.genes - min(seeds.genes))/(max(seeds.genes) -
min(seeds.genes))
}
df_Gene &lt;- data.frame(Gene = names(seeds.genes),
Score = seeds.genes, stringsAsFactors = F)
rownames(df_Gene) &lt;- NULL
df_Gene &lt;- df_Gene[order(df_Gene$Score, decreasing = TRUE),
]
invisible(df_Gene)
}
else {
invisible(df_nGenes)
}
}
else {
df_nGenes &lt;- NULL
if (verbose) {
now &lt;- Sys.time()
message(sprintf("No nearby genes are defined"), appendLF = T)
}
invisible(df_nGenes)
}
}
</pre>


</body></html>
