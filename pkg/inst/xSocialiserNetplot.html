<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xSocialiserNetplot"><tr><td>xSocialiserNetplot</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xSocialiserNetplot</h2>

<h3>Usage</h3>

<pre>
xSocialiserNetplot(g, query, displayBy = c("IC", "none"), path.mode =
c("all_paths", "shortest_paths", "all_shortest_paths"), node.info =
c("none", "term_id", "term_name", "both", "full_term_name"), wrap.width
= 15, colormap = c("yr", "jet", "gbr", "wyr", "br", "bwr", "rainbow",
"wb"), ncolors = 40, zlim = NULL, colorbar = T, newpage = T, glayout =
layout_as_tree, vertex.frame.color = NA, vertex.size = NULL,
vertex.color = NULL, vertex.shape = NULL, vertex.label = NULL,
vertex.label.cex = NULL, vertex.label.dist = 0.3, vertex.label.color =
"blue", edge.arrow.size = 0.3, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>g</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>query</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>displayBy</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.info</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>wrap.width</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>colormap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ncolors</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>zlim</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>colorbar</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>newpage</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>glayout</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.frame.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.shape</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.label</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.label.cex</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.label.dist</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vertex.label.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.arrow.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (g, query, displayBy = c("IC", "none"), path.mode =
c("all_paths",
"shortest_paths", "all_shortest_paths"), node.info = c("none",
"term_id", "term_name", "both", "full_term_name"), wrap.width = 15,
colormap = c("yr", "jet", "gbr", "wyr", "br", "bwr", "rainbow",
"wb"), ncolors = 40, zlim = NULL, colorbar = T, newpage = T,
glayout = layout_as_tree, vertex.frame.color = NA, vertex.size = NULL,
vertex.color = NULL, vertex.shape = NULL, vertex.label = NULL,
vertex.label.cex = NULL, vertex.label.dist = 0.3, vertex.label.color =
"blue",
edge.arrow.size = 0.3, ...)
{
displayBy &lt;- match.arg(displayBy)
path.mode &lt;- match.arg(path.mode)
node.info &lt;- match.arg(node.info)
if (is.logical(g)) {
stop("There is no similarity in the 'igraph' object.\n")
}
if (class(g) != "igraph") {
stop("The function must apply to the 'igraph' object.\n")
}
if (is.null(g$dag)) {
dag &lt;- g
}
else {
dag &lt;- g$dag
}
if (is.null(V(dag)$anno) | is.null(V(dag)$IC)) {
stop("The function requires that input graph has already contained
annotation data and also information content (IC).\n")
}
flag &lt;- sapply(V(dag)$anno, function(x) {
ind &lt;- match(query, x)
if (is.na(ind)) {
0
}
else {
if (is.null(names(x[ind]))) {
1
}
else if (names(x[ind]) == "o") {
1
}
else if (names(x[ind]) == "i") {
2
}
}
})
terms &lt;- V(dag)$name[flag &gt; 0]
terms_origin &lt;- V(dag)$name[flag == 1]
if (length(terms) == 0) {
stop("No terms are found to annotate the entity in query!")
}
subg &lt;- dnet::dDAGinduce(g = dag, nodes_query = terms, path.mode =
path.mode)
inherited &lt;- rep(1, length(V(subg)$name))
names(inherited) &lt;- V(subg)$name
if (length(terms_origin) &gt; 0) {
inherited[terms_origin] &lt;- 0
}
V(subg)$inherited &lt;- inherited
if (displayBy == "IC") {
data &lt;- V(subg)$IC
names(data) &lt;- V(subg)$name
}
else {
data &lt;- NULL
}
if (is.null(vertex.label)) {
getTermInfo &lt;- function(g, vids, numChar = 15, mulLines = F) {
fullNames &lt;- V(g)[vids]$term_name
names(fullNames) &lt;- V(g)[vids]$name
if (mulLines == F) {
shortNames &lt;- paste(substr(fullNames, 1, numChar),
ifelse(nchar(fullNames) &gt; numChar, "...", ""),
sep = "")
}
else {
shortNames &lt;- sapply(fullNames, function(x) {
return(paste(strwrap(x, numChar), sep = "",
collapse = "\n"))
})
}
names(shortNames) &lt;- names(fullNames)
return(shortNames)
}
termNames &lt;- getTermInfo(subg, vids = V(subg)$term_id,
numChar = 15, mulLines = F)
vertex.label &lt;- switch(node.info, none = NULL, term_id =
V(subg)$term_id,
term_name = V(subg)$term_name, both = paste(V(subg)$term_id,
termNames, sep = "\n"), full_term_name = getTermInfo(subg,
vids = V(subg)$term_id, numChar = wrap.width,
mulLines = T))
}
pattern &lt;- data
if (!is.null(pattern)) {
flag &lt;- 0
if (!is.null(names(pattern))) {
pattern &lt;- pattern[V(subg)$name]
}
if (length(pattern) == vcount(subg)) {
flag &lt;- 1
}
if (flag == 1) {
pattern &lt;- as.numeric(pattern)
pattern_nona &lt;- pattern[!is.na(pattern)]
pattern_nona &lt;- as.numeric(pattern_nona)
if (is.null(zlim)) {
vmin &lt;- floor(stats::quantile(pattern_nona, 0.05))
vmax &lt;- ceiling(stats::quantile(pattern_nona,
0.95))
if (vmin &lt; 0 &amp; vmax &gt; 0) {
vsym &lt;- abs(min(vmin, vmax))
vmin &lt;- -1 * vsym
vmax &lt;- vsym
}
zlim &lt;- c(vmin, vmax)
}
vec2color &lt;- function(vec, colormap = colormap, ncolors = ncolors,
zlim = zlim) {
palette.name &lt;- supraHex::visColormap(colormap = colormap)
colors &lt;- palette.name(ncolors)
scale &lt;- length(colors)/(max(zlim) - min(zlim))
sapply(1:length(vec), function(x) {
if (is.na(vec[x])) {
"transparent"
}
else {
ind &lt;- floor(1 + (vec[x] - min(zlim)) * scale)
colors[max(1, min(ncolors, ind))]
}
})
}
vertex.color &lt;- vec2color(pattern, colormap = colormap,
ncolors = ncolors, zlim = zlim)
vertex.frame.color &lt;- vec2color(pattern, colormap = colormap,
ncolors = ncolors, zlim = zlim)
vertex.frame.color[vertex.frame.color == "transparent"] &lt;- "grey"
}
else {
warning("The input 'pattern' is ignored. Please check the help for
enabling your input")
pattern &lt;- NULL
if (is.null(vertex.color)) {
vertex.color &lt;- "SkyBlue2"
}
}
}
else {
if (is.null(vertex.color)) {
vertex.color &lt;- "SkyBlue2"
}
}
par_old &lt;- graphics::par()
dnet::visNet(g = subg, pattern = pattern, colormap = colormap,
ncolors = ncolors, zlim = zlim, colorbar = colorbar,
newpage = newpage, glayout = glayout, vertex.frame.color =
vertex.frame.color,
vertex.size = vertex.size, vertex.color = vertex.color,
vertex.shape = vertex.shape, vertex.label = vertex.label,
vertex.label.cex = vertex.label.cex, vertex.label.dist =
vertex.label.dist,
vertex.label.color = vertex.label.color, edge.arrow.size =
edge.arrow.size,
...)
suppressWarnings(graphics::par(par_old))
invisible(subg)
}
</pre>


</body></html>
