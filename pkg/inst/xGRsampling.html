<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGRsampling"><tr><td>xGRsampling</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGRsampling</h2>

<h3>Usage</h3>

<pre>
xGRsampling(GR.data, GR.background, num.samples = 100, gap.max = 50000,
max.distance = NULL, verbose = T)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>GR.data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.background</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>num.samples</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>gap.max</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>max.distance</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (GR.data, GR.background, num.samples = 100, gap.max = 50000,
max.distance = NULL, verbose = T)
{
if (is.null(max.distance)) {
max.distance &lt;- gap.max
}
else if (max.distance &gt; gap.max) {
max.distance &lt;- gap.max
}
if (class(GR.data) != "GRanges") {
stop("The function must apply to a 'GRanges' object for input data.\n")
}
if (class(GR.background) == "GRangesList") {
GR.background &lt;- BiocGenerics::unlist(GR.background)
}
else if (class(GR.background) == "list") {
GR.background &lt;-
BiocGenerics::unlist(GenomicRanges::GRangesList(GR.background))
}
if (class(GR.background) != "GRanges") {
stop("The function must apply to a 'GRanges' object for input
background.\n")
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("First, get non-overlapping regions for both input data
and background (%s) ...",
as.character(now)), appendLF = T)
}
dGR_reduced &lt;- IRanges::reduce(GR.data)
bGR_reduced &lt;- IRanges::reduce(GR.background)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tnon-overlapping regions: %d for data, %d for
background",
length(dGR_reduced), length(bGR_reduced)), appendLF = T)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Second, keep only data regions that are within
background regions (%s) ...",
as.character(now)), appendLF = T)
}
mergeOverlaps &lt;- function(qGR, sGR, maxgap = -1L, minoverlap = 0L) {
hits &lt;- as.matrix(as.data.frame(GenomicRanges::findOverlaps(query =
qGR,
subject = sGR, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = T)))
qhits &lt;- qGR[hits[, 1]]
shits &lt;- sGR[hits[, 2]]
oGR &lt;- IRanges::pintersect(qhits, shits)
IRanges::reduce(oGR)
}
dGR_reduced &lt;- mergeOverlaps(qGR = dGR_reduced, sGR = bGR_reduced,
maxgap = -1L, minoverlap = 0L)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\t%d within background", length(dGR_reduced)),
appendLF = T)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Third, find background islands that contain data
regions (%s) ...",
as.character(now)), appendLF = T)
}
hits &lt;- as.matrix(as.data.frame(GenomicRanges::findOverlaps(query =
dGR_reduced,
subject = GR.background, maxgap = gap.max - 1, minoverlap = 0L,
type = "any", select = "all", ignore.strand = T)))
ind_data &lt;- hits[, 1]
ind_background &lt;- hits[, 2]
dt_ls &lt;- split(x = ind_background, f = ind_data)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\t%d background islands",
length(unique(ind_background))),
appendLF = T)
}
if (is.null(max.distance)) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Fourth, define the sampling range (%s) ...",
as.character(now)), appendLF = T)
}
}
else {
max.distance &lt;- as.integer(max.distance)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Fourth, define the sampling range within %d bp
distance away from data regions (%s) ...",
max.distance, as.character(now)), appendLF = T)
}
}
df_data &lt;- GenomicRanges::as.data.frame(dGR_reduced, row.names = NULL)
df_background &lt;- GenomicRanges::as.data.frame(GR.background,
row.names = NULL)
range_ls &lt;- lapply(1:length(dt_ls), function(i) {
df_dt &lt;- df_data[as.numeric(names(dt_ls)[i]), ]
dw &lt;- df_dt$width
df_bg &lt;- df_background[dt_ls[[i]], ]
res &lt;- lapply(1:nrow(df_bg), function(j) {
bs &lt;- df_bg$start[j]
be &lt;- df_bg$end[j]
rs &lt;- bs
re &lt;- be - dw
if (!is.null(max.distance)) {
if (rs &lt; df_dt$start - max.distance) {
rs &lt;- df_dt$start - max.distance
}
if (re &gt; df_dt$end + max.distance) {
re &lt;- df_dt$end + max.distance
}
}
seq(rs, re)
})
unlist(res)
})
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Fifth, do '%d' sampling for the starting points (%s)
...",
num.samples, as.character(now)), appendLF = T)
}
res_ls &lt;- lapply(range_ls, function(x) {
base::sample(x, num.samples, replace = T)
})
df_samples &lt;- do.call(rbind, res_ls)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Finally, construct GR for each sampling (%s) ...",
as.character(now)), appendLF = T)
}
df_dt_all &lt;- df_data[as.numeric(names(dt_ls)), ]
sGR_list &lt;- lapply(1:ncol(df_samples), function(j) {
sGR &lt;- GenomicRanges::GRanges(seqnames =
S4Vectors::Rle(df_dt_all$seqnames),
ranges = IRanges::IRanges(start = df_samples[, j],
end = df_samples[, j] + df_dt_all$width - 1),
strand = S4Vectors::Rle(df_dt_all$strand))
})
invisible(sGR_list)
}
</pre>


</body></html>
