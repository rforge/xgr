<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xSNPscores"><tr><td>xSNPscores</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xSNPscores</h2>

<h3>Usage</h3>

<pre>
xSNPscores(data, include.LD = NA, LD.customised = NULL, LD.r2 = 0.8,
significance.threshold = 5e-05, score.cap = 10, verbose = T,
RData.location = "http://galahad.well.ox.ac.uk/bigdata", guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>include.LD</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>LD.customised</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>LD.r2</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>significance.threshold</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>score.cap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, include.LD = NA, LD.customised = NULL, LD.r2 = 0.8,
significance.threshold = 5e-05, score.cap = 10, verbose = T,
RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
if (is.null(data)) {
stop("The input data must be not NULL.\n")
}
else {
if (class(data) == "DataFrame") {
data &lt;- S4Vectors::as.matrix(data)
}
if (is.vector(data)) {
if (length(data) &gt; 1) {
if (is.null(names(data))) {
stop("The input data must have names with attached dbSNP ID.\n")
}
}
else {
data &lt;- utils::read.delim(file = data, header = F,
row.names = NULL, stringsAsFactors = F)
}
}
if (is.vector(data)) {
pval &lt;- data
}
else if (is.matrix(data) | is.data.frame(data)) {
data &lt;- as.matrix(data)
data_list &lt;- split(x = data[, 2], f = as.character(data[,
1]))
res_list &lt;- lapply(data_list, function(x) {
x &lt;- as.numeric(x)
x &lt;- x[!is.na(x)]
if (length(x) &gt; 0) {
min(x)
}
else {
NULL
}
})
pval &lt;- unlist(res_list)
}
tmp &lt;- min(pval[pval != 0])
pval[pval &lt; tmp] &lt;- tmp
}
tmp &lt;- names(pval)
tmp &lt;- gsub("_", ":", tmp, perl = T)
names(pval) &lt;- gsub("imm:", "chr", tmp, perl = T)
Lead_Sig &lt;- data.frame(SNP = names(pval), Sig = pval, row.names = NULL,
stringsAsFactors = F)
leads &lt;- Lead_Sig[, 1]
sigs &lt;- Lead_Sig[, 2]
if (verbose) {
now &lt;- Sys.time()
message(sprintf("A total of %d Lead SNPs are input",
length(leads)), appendLF = T)
}
if (LD.r2 &gt;= 0.8 &amp; LD.r2 &lt;= 1) {
default.include.LD &lt;- c("ACB", "AFR", "AMR", "ASW", "BEB",
"CDX", "CEU", "CHB", "CHS", "CLM", "EAS", "ESN",
"EUR", "FIN", "GBR", "GIH", "GWD", "IBS", "ITU",
"JPT", "KHV", "LWK", "MSL", "MXL", "PEL", "PJL",
"PUR", "SAS", "STU", "TSI", "YRI")
ind &lt;- match(default.include.LD, include.LD)
include.LD &lt;- default.include.LD[!is.na(ind)]
}
else {
include.LD &lt;- NULL
}
LLR &lt;- NULL
if (length(include.LD) &gt; 0 &amp; is.null(LD.customised)) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Inclusion of LD SNPs is based on population (%s) with
R2 &gt;= %f",
paste(include.LD, collapse = ","), LD.r2), appendLF = T)
}
GWAS_LD &lt;- xRDataLoader("GWAS_LD", RData.location = RData.location,
guid = guid, verbose = verbose)
res_list &lt;- lapply(include.LD, function(x) {
data_ld &lt;- ""
eval(parse(text = paste("data_ld &lt;- GWAS_LD$", x,
sep = "")))
ind &lt;- match(rownames(data_ld), leads)
ind_lead &lt;- which(!is.na(ind))
if (length(ind_lead) &gt;= 2) {
ind_ld &lt;- which(Matrix::colSums(data_ld[ind_lead,
] &gt;= LD.r2) &gt; 0)
sLL &lt;- data_ld[ind_lead, ind_ld]
summ &lt;- summary(sLL)
res &lt;- data.frame(Lead = rownames(sLL)[summ$i],
LD = colnames(sLL)[summ$j], R2 = summ$x, stringsAsFactors = F)
}
else if (length(ind_lead) == 1) {
ind_ld &lt;- which(data_ld[ind_lead, ] &gt;= LD.r2)
sLL &lt;- data_ld[ind_lead, ind_ld]
res &lt;- data.frame(Lead = rep(rownames(data_ld)[ind_lead],
length(sLL)), LD = colnames(data_ld)[ind_ld],
R2 = sLL, stringsAsFactors = F)
}
else {
NULL
}
})
LLR &lt;- do.call(rbind, res_list)
if (1) {
ImmunoBase_LD &lt;- xRDataLoader("ImmunoBase_LD", RData.location =
RData.location,
guid = guid, verbose = verbose)
res_list &lt;- lapply(include.LD, function(x) {
data_ld &lt;- ""
eval(parse(text = paste("data_ld &lt;- ImmunoBase_LD$",
x, sep = "")))
ind &lt;- match(rownames(data_ld), leads)
ind_lead &lt;- which(!is.na(ind))
if (length(ind_lead) &gt;= 2) {
ind_ld &lt;- which(Matrix::colSums(data_ld[ind_lead,
] &gt;= LD.r2) &gt; 0)
sLL &lt;- data_ld[ind_lead, ind_ld]
summ &lt;- summary(sLL)
res &lt;- data.frame(Lead = rownames(sLL)[summ$i],
LD = colnames(sLL)[summ$j], R2 = summ$x,
stringsAsFactors = F)
}
else if (length(ind_lead) == 1) {
ind_ld &lt;- which(data_ld[ind_lead, ] &gt;= LD.r2)
sLL &lt;- data_ld[ind_lead, ind_ld]
res &lt;- data.frame(Lead = rep(rownames(data_ld)[ind_lead],
length(sLL)), LD = colnames(data_ld)[ind_ld],
R2 = sLL, stringsAsFactors = F)
}
else {
NULL
}
})
LLR_tmp &lt;- do.call(rbind, res_list)
LLR &lt;- rbind(LLR, LLR_tmp)
}
}
else if (!is.null(LD.customised)) {
if (is.vector(LD.customised)) {
LLR &lt;- utils::read.delim(file = LD.customised, header = F,
row.names = NULL, stringsAsFactors = F)
}
else if (is.matrix(LD.customised) | is.data.frame(LD.customised)) {
LLR &lt;- LD.customised
}
if (!is.null(LLR)) {
flag &lt;- LLR[, 3] &gt;= LD.r2
if (sum(flag) &gt; 0) {
LLR &lt;- LLR[LLR[, 3] &gt;= LD.r2, ]
colnames(LLR) &lt;- c("Lead", "LD", "R2")
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Inclusion of LD SNPs is based on customised data (%d
Lead SNPs and %d LD SNPs) with R2&gt;=%f",
length(unique(LLR[, 1])), length(unique(LLR[,
2])), LD.r2), appendLF = T)
}
}
else {
LLR &lt;- NULL
}
}
}
if (!is.null(LLR)) {
ld_list &lt;- split(x = LLR[, -2], f = LLR[, 2])
res_list &lt;- lapply(ld_list, function(x) {
ind &lt;- match(x$Lead, leads)
min(sigs[ind]^x$R2)
})
vec &lt;- unlist(res_list)
LD_Sig &lt;- data.frame(SNP = names(vec), Sig = vec, row.names = NULL,
stringsAsFactors = F)
df &lt;- rbind(Lead_Sig, as.matrix(LD_Sig))
res_list &lt;- split(x = df$Sig, f = df$SNP)
vec &lt;- unlist(lapply(res_list, min))
SNP_Sig &lt;- data.frame(SNP = names(vec), FDR = vec, row.names = NULL,
stringsAsFactors = F)
}
else {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Do not include any LD SNPs"), appendLF = T)
}
SNP_Sig &lt;- Lead_Sig
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("A total of %d Lead/LD SNPs are considered",
nrow(SNP_Sig)), appendLF = T)
}
pval &lt;- as.numeric(SNP_Sig[, 2])
names(pval) &lt;- SNP_Sig[, 1]
if (is.null(significance.threshold)) {
scores &lt;- log10((1 - pval)/pval)
}
else {
scores &lt;- log10((1 - pval)/pval) - log10((1 -
significance.threshold)/significance.threshold)
}
tmp_max &lt;- max(scores[!is.infinite(scores)])
tmp_min &lt;- min(scores[!is.infinite(scores)])
scores[scores &gt; tmp_max] &lt;- tmp_max
scores[scores &lt; tmp_min] &lt;- tmp_min
ind_remained &lt;- which(scores &gt; 0)
seeds.snps &lt;- scores[ind_remained]
pval &lt;- pval[ind_remained]
if (verbose) {
now &lt;- Sys.time()
message(sprintf("A total of %d Lead/LD SNPs are scored positively",
sum(seeds.snps &gt; 0)), appendLF = T)
}
flag &lt;- rep("Lead", length(pval))
ind &lt;- match(names(pval), Lead_Sig$SNP)
flag[is.na(ind)] &lt;- "LD"
df_SNP &lt;- data.frame(SNP = names(pval), Score = seeds.snps,
Pval = pval, Flag = flag, row.names = NULL, stringsAsFactors = F)
if (!is.null(score.cap)) {
score.cap &lt;- as.numeric(score.cap)
if (score.cap &lt;= max(df_SNP$Score)) {
df_SNP$Score[df_SNP$Score &gt;= score.cap] &lt;- score.cap
if (verbose) {
now &lt;- Sys.time()
message(sprintf("SNP score capped to the maximum score %d.",
score.cap), appendLF = T)
}
}
}
df_SNP &lt;- df_SNP[order(df_SNP$Flag, df_SNP$Score, -df_SNP$Pval,
df_SNP$SNP, decreasing = TRUE), ]
invisible(df_SNP)
}
</pre>


</body></html>
