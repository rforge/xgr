<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xColormap"><tr><td>xColormap</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xColormap</h2>

<h3>Usage</h3>

<pre>
xColormap(colormap = c("bwr", "jet", "gbr", "wyr", "br", "yr",
"rainbow", "wb", "heat", "terrain", "topo", "cm", "ggplot2", "jet.top",
"jet.bottom", "jet.both", "spectral", "ggplot2.top", "ggplot2.bottom",
"ggplot2.both", "RdYlBu", "brewer.BrBG", "brewer.PiYG", "brewer.PRGn",
"brewer.PuOr", "brewer.RdBu", "brewer.RdGy", "brewer.RdYlBu",
"brewer.RdYlGn", "brewer.Spectral", "brewer.Blues", "brewer.BuGn",
"brewer.BuPu", "brewer.GnBu", "brewer.Greens", "brewer.Greys",
"brewer.Oranges", "brewer.OrRd", "brewer.PuBu", "brewer.PuBuGn",
"brewer.PuRd", "brewer.Purples", "brewer.RdPu", "brewer.Reds",
"brewer.YlGn", "brewer.YlGnBu", "brewer.YlOrBr", "brewer.YlOrRd",
"rainbow_hcl", "heat_hcl", "terrain_hcl", "diverge_hcl", "hcl_br",
"hcl_bp", "hcl_bb", "hcl_gp", "hcl_go", "hcl_cp", "hcl_cy", "hcl_co",
"sci_jco", "sci_lancet", "sci_nejm", "sci_locuszoom"), interpolate =
c("spline", "linear"), data = NULL, zlim = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>colormap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>interpolate</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>zlim</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (colormap = c("bwr", "jet", "gbr", "wyr", "br", "yr",
"rainbow", "wb", "heat", "terrain", "topo", "cm", "ggplot2",
"jet.top", "jet.bottom", "jet.both", "spectral", "ggplot2.top",
"ggplot2.bottom", "ggplot2.both", "RdYlBu", "brewer.BrBG",
"brewer.PiYG", "brewer.PRGn", "brewer.PuOr", "brewer.RdBu",
"brewer.RdGy", "brewer.RdYlBu", "brewer.RdYlGn", "brewer.Spectral",
"brewer.Blues", "brewer.BuGn", "brewer.BuPu", "brewer.GnBu",
"brewer.Greens", "brewer.Greys", "brewer.Oranges", "brewer.OrRd",
"brewer.PuBu", "brewer.PuBuGn", "brewer.PuRd", "brewer.Purples",
"brewer.RdPu", "brewer.Reds", "brewer.YlGn", "brewer.YlGnBu",
"brewer.YlOrBr", "brewer.YlOrRd", "rainbow_hcl", "heat_hcl",
"terrain_hcl", "diverge_hcl", "hcl_br", "hcl_bp", "hcl_bb",
"hcl_gp", "hcl_go", "hcl_cp", "hcl_cy", "hcl_co", "sci_jco",
"sci_lancet", "sci_nejm", "sci_locuszoom"), interpolate = c("spline",
"linear"), data = NULL, zlim = NULL)
{
interpolate &lt;- match.arg(interpolate)
if (class(colormap) == "function") {
palette.name &lt;- colormap
}
else {
if (length(colormap) &gt; 1) {
colormap &lt;- colormap[1]
}
if (colormap == "ggplot2") {
my_hue_pal &lt;- function(h = c(0, 360) + 15, c = 100,
l = 65, h.start = 0, direction = 1) {
function(n) {
if ((diff(h)%%360) &lt; 1) {
h[2] &lt;- h[2] - 360/n
}
rotate &lt;- function(x) (x + h.start)%%360 *
direction
hues &lt;- rotate(seq(h[1], h[2], length.out = n))
grDevices::hcl(hues, c, l)
}
}
palette.name &lt;- my_hue_pal(h = c(0, 360) + 15, c = 100,
l = 65, h.start = 0, direction = 1)
}
else if (colormap == "jet.top") {
palette.name &lt;- colorRampPalette(c("#7FFF7F", "yellow",
"#FF7F00", "red", "#7F0000")[-5], interpolate = interpolate)
}
else if (colormap == "jet.bottom") {
palette.name &lt;- colorRampPalette(c("#00007F", "blue",
"#007FFF", "cyan", "#7FFF7F")[-5], interpolate = interpolate)
}
else if (colormap == "jet.both") {
palette.name &lt;- colorRampPalette(c("#00007F", "blue",
"#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00",
"red", "#7F0000")[c(-1, -9)], interpolate = interpolate)
}
else if (colormap == "ggplot2.top") {
palette.name &lt;- colorRampPalette(c("#00C19F", "#00B9E3",
"#619CFF", "#DB72FB", "#FF61C3"), interpolate = interpolate)
}
else if (colormap == "ggplot2.bottom") {
palette.name &lt;- colorRampPalette(c("#F8766D", "#D39200",
"#93AA00", "#00BA38", "#00C19F"), interpolate = interpolate)
}
else if (colormap == "ggplot2.both") {
palette.name &lt;- colorRampPalette(c("#F8766D", "#D39200",
"#93AA00", "#00BA38", "#00C19F", "#00B9E3", "#619CFF",
"#DB72FB", "#FF61C3")[c(-1, -9)], interpolate = interpolate)
}
else if (colormap == "spectral") {
palette.name &lt;- colorRampPalette(rev(c("#D53E4F",
"#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", "#E6F598",
"#ABDDA4", "#66C2A5", "#3288BD")), interpolate = interpolate)
}
else if (colormap == "spectral.both") {
palette.name &lt;- colorRampPalette(rev(c("#D53E4F",
"#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", "#E6F598",
"#ABDDA4", "#66C2A5", "#3288BD"))[c(-1, -9)],
interpolate = interpolate)
}
else if (colormap == "spectral.top") {
palette.name &lt;- colorRampPalette(rev(c("#D53E4F",
"#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF")),
interpolate = interpolate)
}
else if (colormap == "spectral.bottom") {
palette.name &lt;- colorRampPalette(rev(c("#FFFFBF",
"#E6F598", "#ABDDA4", "#66C2A5", "#3288BD")),
interpolate = interpolate)
}
else if (colormap == "RdYlBu") {
palette.name &lt;- colorRampPalette(rev(c("#A50026",
"#D73027", "#F46D43", "#FDAE61", "#FEE090", "#FFFFBF",
"#E0F3F8", "#ABD9E9", "#74ADD1", "#4575B4", "#313695")),
interpolate = interpolate)
}
else if (grepl("^brewer.", colormap)) {
colormap1 &lt;- gsub("^brewer.", "", colormap)
ind &lt;- match(colormap1, rownames(RColorBrewer::brewer.pal.info))
n &lt;- RColorBrewer::brewer.pal.info$maxcolors[ind]
if (n == 11) {
colors &lt;- rev(RColorBrewer::brewer.pal(n, colormap1))
}
else if (n == 9) {
colors &lt;- RColorBrewer::brewer.pal(n, colormap1)
}
palette.name &lt;- colorRampPalette(colors, interpolate = interpolate)
}
else if (colormap == "rainbow_hcl") {
palette.name &lt;- colorRampPalette(c("#E495A5", "#DB9D85",
"#C7A76C", "#ABB065", "#86B875", "#5CBD92", "#39BEB1",
"#4CB9CC", "#7DB0DD", "#ACA4E2", "#CD99D8", "#E093C3"),
interpolate = interpolate)
}
else if (colormap == "heat_hcl") {
palette.name &lt;- colorRampPalette(c("#D33F6A", "#D95260",
"#DE6355", "#E27449", "#E6833D", "#E89331", "#E9A229",
"#EAB12A", "#E9C037", "#E7CE4C", "#E4DC68", "#E2E6BD"),
interpolate = interpolate)
}
else if (colormap == "terrain_hcl") {
palette.name &lt;- colorRampPalette(c("#26A63A", "#5FAB25",
"#84B00E", "#A2B309", "#BDB723", "#D6BA40", "#ECBD5D",
"#FFC07A", "#FFC497", "#FFC8B3", "#FFCFD0", "#F1F1F1"),
interpolate = interpolate)
}
else if (colormap == "diverge_hcl") {
palette.name &lt;- colorRampPalette(c("#023FA5", "#5868AC",
"#848DBC", "#A9AECB", "#C8CAD8", "#DDDEE0", "#E1DDDD",
"#D9C6C9", "#CEA5AC", "#BE7E8A", "#A94F64", "#8E063B"),
interpolate = interpolate)
}
else if (colormap == "hcl_br") {
palette.name &lt;- colorRampPalette(c("#4A6FE3", "#6D84E1",
"#8999E1", "#A4ADE2", "#BDC2E3", "#D6D8E3", "#E4D4D7",
"#E6B8C0", "#E49CAA", "#E18095", "#DB627F", "#D33F6A"),
interpolate = interpolate)
}
else if (colormap == "hcl_bp") {
palette.name &lt;- colorRampPalette(c("#155DB5", "#617EBE",
"#8C9CC9", "#AEB7D3", "#CACEDB", "#DEDEE1", "#E1DEE0",
"#DCCAD4", "#D3ADC3", "#C88AB0", "#BA5F9A", "#AB1E84"),
interpolate = interpolate)
}
else if (colormap == "hcl_bb") {
palette.name &lt;- colorRampPalette(c("#0050B3", "#0071B5",
"#6B92C2", "#9DB1CF", "#C2CBD9", "#DCDEE1", "#E0DDDB",
"#D8C7BE", "#CAA995", "#B78560", "#9E5C00"),
interpolate = interpolate)
}
else if (colormap == "hcl_gp") {
palette.name &lt;- colorRampPalette(c("#005C0065", "#007F0090",
"#5F9E5F65", "#94B99590", "#BECFBE65", "#DBDFDB90",
"#E1DDDF65", "#DBC4D190", "#D1A2BE65", "#C377A790",
"#B33E8E65", "#A3007790"), interpolate = interpolate)
}
else if (colormap == "hcl_go") {
palette.name &lt;- colorRampPalette(c("#11C638", "#68CF72",
"#93D699", "#B4DBB7", "#CDDFCE", "#DEE2DF", "#E4E0DE",
"#E8D7CD", "#EDCBB4", "#F0BC93", "#F1AA68", "#EF9708"),
interpolate = interpolate)
}
else if (colormap == "hcl_cp") {
palette.name &lt;- colorRampPalette(c("#0FCFC0", "#75D8CC",
"#A3DFD7", "#C4E6E1", "#DCECE9", "#EDF0EF", "#F1EEF0",
"#F2E5ED", "#F4D7E8", "#F6C7E2", "#F7B3DC", "#F79CD4"),
interpolate = interpolate)
}
else if (colormap == "hcl_cy") {
palette.name &lt;- colorRampPalette(c("#22FDEB", "#83FAEC",
"#AEF7EE", "#CBF5EF", "#E0F3F0", "#EDF1F0", "#F1F0EE",
"#F3EEE3", "#F6ECD2", "#F9E9BD", "#FBE5A2", "#FEE17F"),
interpolate = interpolate)
}
else if (colormap == "hcl_co") {
palette.name &lt;- colorRampPalette(c("#22FDEB", "#83FAEC",
"#AEF7EE", "#CBF5EF", "#E0F3F0", "#EDF1F0", "#F2F0EE",
"#F8ECE5", "#FFE8D8", "#FFE2C8", "#FFDBB3", "#FFD49A"),
interpolate = interpolate)
}
else if (colormap == "sci_jco") {
palette.name &lt;- colorRampPalette(c("#0073C2FF", "#EFC000FF",
"#868686FF"), interpolate = interpolate)
}
else if (colormap == "sci_nejm") {
palette.name &lt;- colorRampPalette(c("#BC3C29FF", "#0072B5FF",
"#E18727FF", "#20854EFF", "#7876B1FF", "#6F99ADFF",
"#FFDC91FF", "#EE4C97FF"), interpolate = interpolate)
}
else if (colormap == "sci_lancet") {
palette.name &lt;- colorRampPalette(c("#00468BFF", "#ED0000FF",
"#42B540FF", "#0099B4FF", "#925E9FFF", "#FDAF91FF"),
interpolate = interpolate)
}
else if (colormap == "sci_locuszoom") {
palette.name &lt;- colorRampPalette(c("#D43F3AFF", "#EEA236FF",
"#5CB85CFF", "#46B8DAFF", "#357EBDFF", "#9632B8FF"),
interpolate = interpolate)
}
else if (colormap == "heat") {
palette.name &lt;- grDevices::heat.colors
}
else if (colormap == "terrain") {
palette.name &lt;- grDevices::terrain.colors
}
else if (colormap == "topo") {
palette.name &lt;- grDevices::topo.colors
}
else if (colormap == "cm") {
palette.name &lt;- grDevices::cm.colors
}
else {
palette.name &lt;- supraHex::visColormap(colormap = colormap)
}
}
if (!is.null(data)) {
if (is.numeric(data)) {
if (is.null(zlim)) {
vmin &lt;- floor(stats::quantile(data, 0.05))
vmax &lt;- ceiling(stats::quantile(data, 0.95))
if (vmin &lt; 0 &amp; vmax &gt; 0) {
vsym &lt;- abs(min(vmin, vmax))
vmin &lt;- -1 * vsym
vmax &lt;- vsym
}
zlim &lt;- c(vmin, vmax)
}
data[data &lt; zlim[1]] &lt;- zlim[1]
data[data &gt; zlim[2]] &lt;- zlim[2]
cut_index &lt;- as.numeric(cut(data, breaks = min(data) +
(max(data) - min(data)) * seq(0, 1, len = 64)))
cut_index[is.na(cut_index)] &lt;- 1
res &lt;- palette.name(64)[cut_index]
return(res)
}
}
invisible(palette.name)
}
</pre>


</body></html>
