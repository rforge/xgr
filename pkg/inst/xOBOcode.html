<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xOBOcode"><tr><td>xOBOcode</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xOBOcode</h2>

<h3>Usage</h3>

<pre>
xOBOcode(g, node.level = "term_distance", node.level.value = 2,
node.label.size = 2, node.label.color = "darkblue", node.label.alpha =
0.8, node.label.padding = 0, node.label.arrow = 0.01, node.label.force
= 0, node.shape = 19, node.xcoord = NULL, node.ycoord = NULL,
node.color = NULL, node.color.title = NULL, colormap = "grey-grey",
ncolors = 64, zlim = NULL, node.size.range = 4, title = "", edge.size =
0.5, edge.color = "black", edge.color.alpha = 0.4, edge.curve = 0.1,
edge.arrow = 2, edge.arrow.gap = 0.02, node.table = "term_name",
node.table.wrap = 50, table.base.size = 7, table.row.space = 2,
table.nrow = 55, table.ncol = NULL, root.code = "RT")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>g</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.level</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.level.value</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.alpha</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.padding</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.arrow</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.force</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.shape</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.xcoord</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.ycoord</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.color.title</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>colormap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ncolors</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>zlim</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.size.range</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>title</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.color.alpha</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.curve</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.arrow</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.arrow.gap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.table</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.table.wrap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>table.base.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>table.row.space</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>table.nrow</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>table.ncol</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>root.code</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (g, node.level = "term_distance", node.level.value = 2,
node.label.size = 2, node.label.color = "darkblue", node.label.alpha =
0.8,
node.label.padding = 0, node.label.arrow = 0.01, node.label.force = 0,
node.shape = 19, node.xcoord = NULL, node.ycoord = NULL,
node.color = NULL, node.color.title = NULL, colormap = "grey-grey",
ncolors = 64, zlim = NULL, node.size.range = 4, title = "",
edge.size = 0.5, edge.color = "black", edge.color.alpha = 0.4,
edge.curve = 0.1, edge.arrow = 2, edge.arrow.gap = 0.02,
node.table = "term_name", node.table.wrap = 50, table.base.size = 7,
table.row.space = 2, table.nrow = 55, table.ncol = NULL,
root.code = "RT")
{
if (any(class(g) %in% c("igraph"))) {
ig &lt;- g
}
else {
stop("The function must apply to a 'igraph' object.\n")
}
if (is.null(node.level)) {
stop("The node level must be provided!\n")
}
else {
node.level &lt;- igraph::vertex_attr(ig, node.level)
if (is.null(node.level)) {
stop("The node level provided does not exist!\n")
}
}
ind &lt;- which(node.level == node.level.value)
if (length(ind) == 0) {
stop("The node level value provided is wrong!\n")
}
vec.name &lt;- V(ig)$name[ind]
V(ig)$node.code &lt;- root.code
for (k in 1:length(vec.name)) {
x &lt;- vec.name[k]
neighs.out &lt;- igraph::neighborhood(ig, order = vcount(ig),
nodes = x, mode = "out")
neighbors &lt;- names(unlist(neighs.out))
tmp &lt;- igraph::distances(ig, v = x, to = V(ig), mode = "out")[1,
]
ind &lt;- match(names(tmp), V(ig)$name[V(ig)$code != root.code])
tmp &lt;- tmp[is.na(ind)]
tmp &lt;- tmp[!is.infinite(tmp)]
if (k &lt;= 26) {
code1 &lt;- letters[k]
}
else {
code1 &lt;- LETTERS[k - 26]
}
V(ig)[names(tmp)[tmp == 0]]$node.code &lt;- code1
ind &lt;- which(tmp != 0)
ttmp &lt;- base::make.unique(as.character(tmp[ind]), sep = "-")
tmp_ls &lt;- lapply(strsplit(ttmp, "-"), function(x) {
x &lt;- as.numeric(x)
a &lt;- x[1]
if (a &gt;= 10 &amp; a &lt;= 35) {
a &lt;- letters[a - 9]
}
else if (a &gt; 35) {
a &lt;- LETTERS[a - 35]
}
if (length(x) == 1) {
c(a, 1)
}
else {
b &lt;- x[2] + 1
if (b &gt;= 10 &amp; b &lt;= 35) {
b &lt;- letters[b - 9]
}
else if (b &gt; 35 &amp; b &lt;= 61) {
b &lt;- LETTERS[b - 35]
}
c(a, b)
}
})
tmp_mat &lt;- do.call(rbind, tmp_ls)
V(ig)[names(tmp)[ind]]$node.code &lt;- paste0(code1, tmp_mat[,
1], tmp_mat[, 2])
}
gp_code &lt;- xGGnetwork(g = ig, node.label = "node.code",
label.wrap.width = 30,
node.label.size = node.label.size, node.label.color = node.label.color,
node.label.alpha = node.label.alpha, node.label.padding =
node.label.padding,
node.label.arrow = node.label.arrow, node.label.force =
node.label.force,
node.shape = node.shape, node.xcoord = node.xcoord, node.ycoord =
node.ycoord,
node.color = node.color, node.color.title = node.color.title,
colormap = colormap, ncolors = ncolors, zlim = zlim,
node.size.range = node.size.range, title = title, edge.size =
edge.size,
edge.color = edge.color, edge.color.alpha = edge.color.alpha,
edge.curve = edge.curve, edge.arrow = edge.arrow, edge.arrow.gap =
edge.arrow.gap)
if (is.null(node.table)) {
stop("The node name must be provided for the table!\n")
}
else {
node.table &lt;- igraph::vertex_attr(ig, node.table)
if (is.null(node.table)) {
stop("The node name for the table provided does not exist!\n")
}
}
res_list &lt;- lapply(node.table, function(x) {
if (!is.na(x)) {
x &lt;- gsub("_", " ", x)
y &lt;- strwrap(x, width = node.table.wrap)
if (length(y) == 2) {
paste(y, collapse = "\n")
}
else if (length(y) &gt; 2) {
paste0(paste(y[1:2], collapse = "\n"), "...")
}
else {
y
}
}
else {
x
}
})
V(ig)$node.table &lt;- unlist(res_list)
df_code &lt;- data.frame(Code = V(ig)$node.code, Name = V(ig)$node.table,
stringsAsFactors = FALSE)
Code &lt;- NULL
df_code &lt;- df_code %&gt;% dplyr::arrange(Code)
tt &lt;- gridExtra::ttheme_default(base_size = table.base.size,
padding = unit(c(1, 1), "mm"), core = list(fg_params = list(lineheight
= 0.8,
fontfamily = "sans"), bg_params = list(fill = c("snow1",
"snow2"))), colhead = list(bg_params = list(fill = "snow3"),
fg_params = list(cex = 1)), rowhead = list(fg_params = list(hjust = 0,
x = 0, fontface = "bold.italic"), bg_params = list(fill = c("snow2",
"snow1"))), )
if (0) {
ind &lt;- base::nchar(df_code$Code) == 1 | df_code$Code ==
root.code
df_code_sub &lt;- df_code[ind, ]
df_code_other &lt;- df_code[!ind, ]
ls_gt &lt;- lapply(df_code_sub$Code, function(x) {
ind &lt;- grep(x, df_code_other$Code)
if (length(ind) &gt; 0) {
gridExtra::tableGrob(df_code_other[ind, ], theme = tt,
rows = NULL)
}
else {
NULL
}
})
ls_gt &lt;- base::Filter(base::Negate(is.null), ls_gt)
gridExtra::grid.arrange(grobs = ls_gt, ncol = 3, as.table = TRUE)
gx &lt;- grid::textGrob("aa")
}
else {
ind_root &lt;- df_code$Code == root.code
ind_sub &lt;- base::nchar(df_code$Code) == 1
df_code_sub &lt;- df_code[ind_sub, ]
df_code_other &lt;- df_code[!(ind_sub | ind_root), ]
ls_df &lt;- lapply(df_code_sub$Code, function(x) {
ind &lt;- base::grep(paste0("^", x), df_code_other$Code)
df_code_other[ind, ]
})
df_code_order &lt;- rbind(df_code[ind_root, ], df_code_sub,
do.call(rbind, ls_df))
if (0) {
vec &lt;- ggplot2::cut_interval(1:nrow(df_code_order),
length = 20)
}
else {
vec_length &lt;- unlist(lapply(strsplit(df_code_order$Name,
"\n"), length))
vec_length[vec_length == 2] &lt;- table.row.space
vec &lt;- ggplot2::cut_interval(cumsum(vec_length),
length = table.nrow)
}
ls_gt &lt;- lapply(unique(vec), function(x) {
ind &lt;- which(vec == x)
y &lt;- df_code_order[ind, ]
diff &lt;- table.nrow - sum(vec_length[ind])
if (diff &gt; 0) {
z &lt;- matrix(rep(c("", ""), diff), ncol = 2)
colnames(z) &lt;- c("Code", "Name")
y &lt;- rbind(y, z)
}
if (0) {
rownames(y) &lt;- y$Code
y &lt;- subset(y, select = "Name")
gridExtra::tableGrob(y, theme = tt)
}
else {
gridExtra::tableGrob(y, theme = tt, rows = NULL)
}
})
ls_gt &lt;- base::Filter(base::Negate(is.null), ls_gt)
if (is.null(table.ncol)) {
table.ncol &lt;- 3
}
if (length(unique(vec)) &lt; table.ncol) {
table.ncol &lt;- length(unique(vec))
}
top &lt;- ""
if (table.ncol &gt; 3) {
top &lt;- quote(paste("page", g, "of", pages))
}
gp_table &lt;- gridExtra::marrangeGrob(ls_gt, ncol = table.ncol,
nrow = 1, as.table = FALSE, top = top)
}
ls_gp &lt;- list(code = gp_code, table = gp_table, ig = ig)
invisible(ls_gp)
}
</pre>


</body></html>
