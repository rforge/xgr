<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xEnrichLadder"><tr><td>xEnrichLadder</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xEnrichLadder</h2>

<h3>Usage</h3>

<pre>
xEnrichLadder(eTerm, sortBy = c("fdr", "or", "adjp", "pvalue",
"zscore", "fc", "nAnno", "nOverlap", "none"), top_num = 5, FDR.cutoff =
0.05, CI.one = T, colormap = "lightgrey-grey-black", x.rotate = 90,
x.text.size = 6, y.text.size = 6, shape = 22, size = 2, label =
c("concise", "full"), verbose = T, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>eTerm</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>sortBy</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>top_num</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>FDR.cutoff</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>CI.one</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>colormap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>x.rotate</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>x.text.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>y.text.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>shape</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>label</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (eTerm, sortBy = c("fdr", "or", "adjp", "pvalue", "zscore",
"fc", "nAnno", "nOverlap", "none"), top_num = 5, FDR.cutoff = 0.05,
CI.one = T, colormap = "lightgrey-grey-black", x.rotate = 90,
x.text.size = 6, y.text.size = 6, shape = 22, size = 2, label =
c("concise",
"full"), verbose = T, ...)
{
sortBy &lt;- match.arg(sortBy)
label &lt;- match.arg(label)
gp_heatmap &lt;- NULL
if (class(eTerm) == "eTerm") {
df &lt;- xEnrichViewer(eTerm, top_num = "all")
if (!CI.one) {
ind &lt;- which(df$CIl &gt; 1 | df$CIu &lt; 1)
df &lt;- df[ind, ]
}
if (FDR.cutoff == 1) {
FDR.cutoff &lt;- FDR.cutoff + 0.01
}
if (top_num == "auto") {
top_num &lt;- sum(df$adjp &lt; FDR.cutoff)
if (top_num &lt;= 1) {
top_num &lt;- 10
}
}
df_enrichment &lt;- xEnrichViewer(eTerm, top_num = top_num,
sortBy = sortBy, details = T)
}
else if (class(eTerm) == "data.frame") {
df_enrichment &lt;- eTerm
}
if (!is.null(df_enrichment)) {
if (label == "concise") {
df_enrichment$label &lt;- paste0(df_enrichment$name,
" [OR=", df_enrichment$or, ", FDR=", df_enrichment$adjp,
", n=", df_enrichment$nOverlap, "/", df_enrichment$nAnno,
"]")
}
else {
df_enrichment$label &lt;- paste0(df_enrichment$name,
"\n[OR=", df_enrichment$or, ", P=", df_enrichment$pvalue,
", FDR=", df_enrichment$adjp, ", n=", df_enrichment$nOverlap,
"/", df_enrichment$nAnno, "]")
}
df_enrichment &lt;- df_enrichment[!duplicated(df_enrichment$name),
]
ls_path &lt;- lapply(1:nrow(df_enrichment), function(j) {
x &lt;- df_enrichment$members_Overlap[j]
query &lt;- unlist(strsplit(x, ", "))
})
names(ls_path) &lt;- df_enrichment$name
if (length(ls_path) &gt;= 1) {
all_genes &lt;- unique(unlist(ls_path))
ls_vec &lt;- lapply(1:length(ls_path), function(j) {
ind &lt;- match(all_genes, ls_path[[j]])
vec &lt;- rep(NA, length(all_genes))
vec[!is.na(ind)] &lt;- names(ls_path)[j]
vec
})
df_res &lt;- do.call(cbind, ls_vec)
colnames(df_res) &lt;- names(ls_path)
rownames(df_res) &lt;- all_genes
vec_sum &lt;- apply(!is.na(df_res), 1, sum)
df_tmp &lt;- data.frame(num = vec_sum, df_res, gene = rownames(df_res),
stringsAsFactors = F)
df_tmp &lt;- df_tmp %&gt;% dplyr::arrange_all()
df_tmp &lt;- df_tmp[nrow(df_tmp):1, ]
colnames(df_tmp)[2:(ncol(df_tmp) - 1)] &lt;- colnames(df_res)
vec_sum &lt;- df_tmp$num
names(vec_sum) &lt;- df_tmp$gene
df_res &lt;- df_tmp %&gt;% dplyr::select(2:(ncol(df_tmp) -
1))
rownames(df_res) &lt;- df_tmp$gene
if (verbose) {
message(sprintf("heatmap of %d rows X %d columns (%s) ...",
nrow(df_res), ncol(df_res), as.character(Sys.time())),
appendLF = TRUE)
}
if (1) {
df_heatmap &lt;- 0 + !is.na(df_res)
df_heatmap[df_heatmap == 0] &lt;- NA
for (i in 1:nrow(df_heatmap)) {
x &lt;- df_heatmap[i, ]
df_heatmap[i, !is.na(x)] &lt;- vec_sum[i]
}
mat_heatmap &lt;- t(df_heatmap)
ind &lt;- match(rownames(mat_heatmap), df_enrichment$name)
rownames(mat_heatmap) &lt;- df_enrichment$label[ind]
gp_heatmap &lt;- xHeatmap(mat_heatmap, reorder = "none",
colormap = colormap, zlim = c(0, max(mat_heatmap,
na.rm = T)), ncolors = 64, barwidth = 0.4,
x.rotate = x.rotate, x.text.size = x.text.size,
y.text.size = y.text.size, shape = shape, size = size,
na.color = "transparent", ...)
gp_heatmap &lt;- gp_heatmap + theme(legend.title = element_text(size = 8),
legend.position = "none") + scale_y_discrete(position = "right")
colsep &lt;- cumsum(table(vec_sum))
colsep &lt;- length(vec_sum) - colsep[-length(colsep)]
gp_heatmap &lt;- gp_heatmap + geom_vline(xintercept = colsep +
0.5, color = "grey90", size = 0.5)
gene &lt;- sample &lt;- val &lt;- NULL
data_matrix &lt;- gp_heatmap$data %&gt;% dplyr::select(gene,
sample, val) %&gt;% tidyr::spread(sample, val)
rownames(data_matrix) &lt;- data_matrix$gene
data_matrix &lt;- data_matrix[, -1]
gp_heatmap$matrix &lt;- data_matrix
}
}
}
return(gp_heatmap)
}
</pre>


</body></html>
