<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xEnricherYours"><tr><td>xEnricherYours</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xEnricherYours</h2>

<h3>Usage</h3>

<pre>
xEnricherYours(data.file, annotation.file, background.file = NULL,
size.range = c(10, 2000), min.overlap = 5, test = c("fisher",
"hypergeo", "binomial"), background.annotatable.only = NULL, p.tail =
c("one-tail", "two-tails"), p.adjust.method = c("BH", "BY",
"bonferroni", "holm", "hochberg", "hommel"), verbose = T, silent =
FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>annotation.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>size.range</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>min.overlap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>test</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.annotatable.only</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.tail</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.adjust.method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>silent</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data.file, annotation.file, background.file = NULL,
size.range = c(10, 2000), min.overlap = 5, test = c("fisher",
"hypergeo", "binomial"), background.annotatable.only = NULL,
p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH",
"BY", "bonferroni", "holm", "hochberg", "hommel"), verbose = T,
silent = FALSE)
{
startT &lt;- Sys.time()
if (!silent) {
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = TRUE)
message("", appendLF = TRUE)
}
else {
verbose &lt;- FALSE
}
test &lt;- match.arg(test)
p.tail &lt;- match.arg(p.tail)
p.adjust.method &lt;- match.arg(p.adjust.method)
p.tail &lt;- match.arg(p.tail)
if (length(data.file) == 0) {
return(NULL)
}
if (is.matrix(data.file) | is.data.frame(data.file)) {
data &lt;- unique(data.file[, 1])
}
else if (!is.null(data.file) &amp; any(!is.na(data.file))) {
if (length(data.file) == 1) {
if (class(suppressWarnings(try(data &lt;- utils::read.delim(file =
data.file,
header = F, row.names = NULL, stringsAsFactors = F),
T))) == "try-error") {
data &lt;- data.file
}
else {
data &lt;- unique(data[, 1])
}
}
else {
data &lt;- data.file
}
}
else {
stop("The file 'data.file' must be provided!\n")
}
if (is.matrix(background.file) | is.data.frame(background.file)) {
background &lt;- unique(background.file[, 1])
}
else if (!is.null(background.file)) {
if (length(background.file) == 1) {
background &lt;- utils::read.delim(file = background.file,
header = F, row.names = NULL, stringsAsFactors = F)
background &lt;- unique(background[, 1])
}
else {
background &lt;- background.file
}
}
else {
background &lt;- background.file
}
if (is.matrix(annotation.file) | is.data.frame(annotation.file)) {
input &lt;- cbind(annotation.file[, 1], annotation.file[,
2])
}
else if (!is.null(annotation.file) &amp; any(!is.na(annotation.file))) {
input &lt;- utils::read.delim(file = annotation.file, header = F,
row.names = NULL, stringsAsFactors = F)
}
else {
stop("The file 'annotation.file' must be provided!\n")
}
if (0) {
if (background.annotatable.only == FALSE) {
if (!is.null(background.file)) {
tmp &lt;- cbind(background.file, rep("BG", length(background.file)))
input &lt;- rbind(input, tmp)
}
}
}
anno &lt;- split(x = input[, 1], f = input[, 2])
terms &lt;- names(anno)
nodes &lt;- data.frame(name = terms, term_id = terms, term_name = terms,
term_distance = rep(1, length(terms)), term_namespace =
rep("Customised",
length(terms)), stringsAsFactors = F)
root &lt;- c("Root", "Root", "Root", 0, "Customised")
nodes &lt;- rbind(nodes, root)
relations &lt;- data.frame(from = "Root", to = nodes$name)
g &lt;- igraph::graph.data.frame(d = relations, directed = T,
vertices = nodes)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\n#######################################################",
appendLF = T))
message(sprintf("'xEnricher' is being called (%s):",
as.character(now)), appendLF = T)
message(sprintf("#######################################################",
appendLF = T))
}
eTerm &lt;- xEnricher(data = data, annotation = anno, g = g,
background = background, size.range = size.range, min.overlap =
min.overlap,
test = test, background.annotatable.only = background.annotatable.only,
p.tail = p.tail, p.adjust.method = p.adjust.method, ontology.algorithm
= "none",
true.path.rule = F, verbose = verbose)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("#######################################################",
appendLF = T))
message(sprintf("'xEnricher' has been finished (%s)!",
as.character(now)), appendLF = T)
message(sprintf("#######################################################\n",
appendLF = T))
}
endT &lt;- Sys.time()
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
if (!silent) {
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = TRUE)
message(paste(c("Runtime in total (xEnricherYours): ",
runTime, " secs\n"), collapse = ""), appendLF = TRUE)
}
invisible(eTerm)
}
</pre>


</body></html>
