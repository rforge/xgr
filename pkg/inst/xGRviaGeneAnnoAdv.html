<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGRviaGeneAnnoAdv"><tr><td>xGRviaGeneAnnoAdv</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGRviaGeneAnnoAdv</h2>

<h3>Usage</h3>

<pre>
xGRviaGeneAnnoAdv(list_vec, background = NULL, build.conversion = c(NA,
"hg38.to.hg19", "hg18.to.hg19"), gap.max = 0, GR.Gene =
c("UCSC_knownGene", "UCSC_knownCanonical"), ontologies = NA, size.range
= c(10, 2000), min.overlap = 5, which.distance = NULL, test =
c("fisher", "hypergeo", "binomial"), background.annotatable.only =
NULL, p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH",
"BY", "bonferroni", "holm", "hochberg", "hommel"), ontology.algorithm =
c("none", "pc", "elim", "lea"), elim.pvalue = 0.01, lea.depth = 2,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = F, verbose = T, silent = FALSE, plot = TRUE,
fdr.cutoff = 0.05, displayBy = c("zscore", "fdr", "pvalue", "fc",
"or"), RData.location = "http://galahad.well.ox.ac.uk/bigdata", guid =
NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>list_vec</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>build.conversion</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>gap.max</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.Gene</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontologies</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>size.range</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>min.overlap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>which.distance</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>test</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.annotatable.only</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.tail</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.adjust.method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontology.algorithm</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>elim.pvalue</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>lea.depth</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>true.path.rule</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>silent</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>plot</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>fdr.cutoff</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>displayBy</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (list_vec, background = NULL, build.conversion = c(NA,
"hg38.to.hg19", "hg18.to.hg19"), gap.max = 0, GR.Gene =
c("UCSC_knownGene",
"UCSC_knownCanonical"), ontologies = NA, size.range = c(10,
2000), min.overlap = 5, which.distance = NULL, test = c("fisher",
"hypergeo", "binomial"), background.annotatable.only = NULL,
p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH",
"BY", "bonferroni", "holm", "hochberg", "hommel"), ontology.algorithm =
c("none",
"pc", "elim", "lea"), elim.pvalue = 0.01, lea.depth = 2,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = F, verbose = T, silent = FALSE, plot = TRUE,
fdr.cutoff = 0.05, displayBy = c("zscore", "fdr", "pvalue",
"fc", "or"), RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
startT &lt;- Sys.time()
if (!silent) {
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = TRUE)
message("", appendLF = TRUE)
}
else {
verbose &lt;- FALSE
}
build.conversion &lt;- match.arg(build.conversion)
test &lt;- match.arg(test)
p.tail &lt;- match.arg(p.tail)
p.adjust.method &lt;- match.arg(p.adjust.method)
ontology.algorithm &lt;- match.arg(ontology.algorithm)
path.mode &lt;- match.arg(path.mode)
displayBy &lt;- match.arg(displayBy)
if (length(list_vec) == 0) {
return(NULL)
}
if (is.vector(list_vec) &amp; class(list_vec) != "list") {
list_vec &lt;- list(list_vec)
}
else if (class(list_vec) == "list") {
list_vec &lt;- base::Filter(base::Negate(is.null), list_vec)
if (length(list_vec) == 0) {
return(NULL)
}
}
else {
stop("The input data must be a vector or a list of vectors.\n")
}
list_names &lt;- names(list_vec)
if (is.null(list_names)) {
list_names &lt;- paste0("G", 1:length(list_vec))
names(list_vec) &lt;- list_names
}
ls_df &lt;- lapply(1:length(list_vec), function(i) {
if (verbose) {
message(sprintf("Analysing group %d ('%s') (%s) ...",
i, names(list_vec)[i], as.character(Sys.time())),
appendLF = T)
}
data &lt;- list_vec[[i]]
ls_df &lt;- lapply(1:length(ontologies), function(j) {
if (verbose) {
message(sprintf("\tontology %d ('%s') (%s) ...",
j, ontologies[j], as.character(Sys.time())),
appendLF = T)
}
ontology &lt;- ontologies[j]
eTerm &lt;- xGRviaGeneAnno(data.file = data, background.file = background,
format.file = "chr:start-end", build.conversion = build.conversion,
gap.max = gap.max, GR.Gene = GR.Gene, ontology = ontology,
size.range = size.range, min.overlap = min.overlap,
which.distance = which.distance, test = test,
background.annotatable.only = background.annotatable.only,
p.tail = p.tail, p.adjust.method = p.adjust.method,
ontology.algorithm = ontology.algorithm, elim.pvalue = elim.pvalue,
lea.depth = lea.depth, path.mode = path.mode,
true.path.rule = true.path.rule, verbose = verbose,
RData.location = RData.location, guid = guid)
df &lt;- xEnrichViewer(eTerm, top_num = "all", sortBy = "or",
details = TRUE)
if (is.null(df)) {
return(NULL)
}
else {
cbind(group = rep(names(list_vec)[i], nrow(df)),
ontology = rep(ontology, nrow(df)), id = rownames(df),
df, stringsAsFactors = F)
}
})
df &lt;- do.call(rbind, ls_df)
})
df_all &lt;- do.call(rbind, ls_df)
if (plot &amp; !is.null(df_all)) {
adjp &lt;- NULL
gp &lt;- NULL
mat &lt;- NULL
ls_df &lt;- split(x = df_all[, -12], f = df_all$ontology)
ls_df &lt;- ls_df[unique(df_all$ontology)]
ls_mat &lt;- lapply(1:length(ls_df), function(i) {
df &lt;- ls_df[[i]]
ind &lt;- which(df$adjp &lt; fdr.cutoff)
if (length(ind) &gt;= 1) {
df &lt;- as.data.frame(df %&gt;% dplyr::filter(adjp &lt;
fdr.cutoff))
if (displayBy == "fdr") {
mat &lt;- as.matrix(xSparseMatrix(df[, c("name",
"group", "adjp")], rows = unique(df$name),
columns = names(list_vec)))
mat[mat == 0] &lt;- NA
mat &lt;- -log10(mat)
}
else if (displayBy == "pvalue") {
mat &lt;- as.matrix(xSparseMatrix(df[, c("name",
"group", "pvalue")], rows = unique(df$name),
columns = names(list_vec)))
mat[mat == 0] &lt;- NA
mat &lt;- -log10(mat)
}
else if (displayBy == "zscore") {
mat &lt;- as.matrix(xSparseMatrix(df[, c("name",
"group", "zscore")], rows = unique(df$name),
columns = names(list_vec)))
mat[mat == 0] &lt;- NA
}
else if (displayBy == "fc") {
mat &lt;- as.matrix(xSparseMatrix(df[, c("name",
"group", "fc")], rows = unique(df$name),
columns = names(list_vec)))
mat[mat == 0] &lt;- NA
mat &lt;- log2(mat)
}
else if (displayBy == "or") {
mat &lt;- as.matrix(xSparseMatrix(df[, c("name",
"group", "or")], rows = unique(df$name),
columns = names(list_vec)))
mat[mat == 0] &lt;- NA
mat &lt;- log2(mat)
}
if (nrow(mat) == 1) {
df_mat &lt;- mat
}
else {
rname_ordered &lt;- rownames(mat)[order(-nchar(rownames(mat)))]
if (names(ls_df)[i] == "PS2") {
df_tmp &lt;- unique(df[, c("id", "name")])
df_tmp &lt;- df_tmp[with(df_tmp, order(as.numeric(df_tmp$id))),
]
rname_ordered &lt;- df_tmp$name
}
ind &lt;- match(rname_ordered, rownames(mat))
df_mat &lt;- as.matrix(mat[ind, ], ncol = ncol(mat))
colnames(df_mat) &lt;- colnames(mat)
colnames(df_mat) &lt;- colnames(mat)
}
return(df_mat)
}
else {
return(NULL)
}
})
mat &lt;- do.call(rbind, ls_mat)
if (!is.null(mat)) {
if (displayBy == "fdr" | displayBy == "pvalue") {
colormap &lt;- "grey100-darkorange"
zlim &lt;- c(0, ceiling(max(mat[!is.na(mat)])))
if (displayBy == "fdr") {
legend.title &lt;- expression(-log[10]("FDR"))
}
else if (displayBy == "pvalue") {
legend.title &lt;- expression(-log[10]("p-value"))
}
}
else if (displayBy == "fc" | displayBy == "zscore" |
displayBy == "or") {
tmp_max &lt;- ceiling(max(mat[!is.na(mat)]))
tmp_min &lt;- floor(min(mat[!is.na(mat)]))
if (tmp_max &gt; 0 &amp; tmp_min &lt; 0) {
colormap &lt;- "deepskyblue-grey100-darkorange"
tmp &lt;- max(tmp_max, abs(tmp_min))
zlim &lt;- c(-tmp, tmp)
}
else if (tmp_max &lt;= 0) {
colormap &lt;- "deepskyblue-grey100"
zlim &lt;- c(tmp_min, 0)
}
else if (tmp_min &gt;= 0) {
colormap &lt;- "grey100-darkorange"
zlim &lt;- c(0, tmp_max)
}
if (displayBy == "fc") {
legend.title &lt;- expression(log[2]("FC"))
}
else if (displayBy == "zscore") {
legend.title &lt;- ("Z-score")
}
else if (displayBy == "or") {
legend.title &lt;- expression(log[2]("OR"))
}
}
gp &lt;- xHeatmap(mat, reorder = "none", colormap = colormap,
ncolors = 64, zlim = zlim, legend.title = legend.title,
barwidth = 0.4, x.rotate = 60, shape = 19, size = 2,
x.text.size = 6, y.text.size = 6, na.color = "transparent",
barheight = max(3, min(5, nrow(mat))))
gp &lt;- gp + theme(legend.title = element_text(size = 8))
}
}
else {
gp &lt;- NULL
mat &lt;- NULL
}
ls_eTerm &lt;- list(df = df_all, mat = mat, gp = gp)
class(ls_eTerm) &lt;- "ls_eTerm"
endT &lt;- Sys.time()
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
if (!silent) {
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = TRUE)
message(paste(c("Runtime in total is: ", runTime, " secs\n"),
collapse = ""), appendLF = TRUE)
}
invisible(ls_eTerm)
}
</pre>


</body></html>
