<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xSNPlocations"><tr><td>xSNPlocations</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xSNPlocations</h2>

<h3>Usage</h3>

<pre>
xSNPlocations(data, GR.SNP = c("dbSNP_GWAS", "dbSNP_Common",
"dbSNP_Single"), verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata", guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.SNP</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, GR.SNP = c("dbSNP_GWAS", "dbSNP_Common",
"dbSNP_Single"),
verbose = T, RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
data &lt;- gsub("_", ":", data, perl = T)
data &lt;- gsub("imm:", "chr", data, perl = T)
data &lt;- unique(data)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Load positional information for SNPs (%s) ...",
as.character(now)), appendLF = T)
}
if (class(GR.SNP) == "GRanges") {
pos_SNP &lt;- GR.SNP
}
else {
pos_SNP &lt;- xRDataLoader(GR.SNP[1], verbose = verbose,
RData.location = RData.location, guid = guid)
if (is.null(pos_SNP)) {
GR.SNP &lt;- "dbSNP_GWAS"
if (verbose) {
message(sprintf("Instead, %s will be used", GR.SNP),
appendLF = T)
}
pos_SNP &lt;- xRDataLoader(GR.SNP, verbose = verbose,
RData.location = RData.location, guid = guid)
}
}
ind &lt;- match(data, names(pos_SNP))
data_rest &lt;- data[is.na(ind)]
ind &lt;- ind[!is.na(ind)]
if (length(ind)) {
gr_SNP &lt;- pos_SNP[ind, ]
GenomicRanges::mcols(gr_SNP) &lt;- NULL
}
else {
gr_SNP &lt;- NULL
}
ind &lt;- grep("^chr\w+:\d+", data_rest, perl = T)
if (length(ind) &gt; 0) {
data_rest &lt;- data_rest[ind]
res_ls &lt;- strsplit(data_rest, ":")
res_df &lt;- do.call(rbind, res_ls)
res_gr &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(res_df[,
1]), ranges = IRanges::IRanges(start = as.numeric(res_df[,
2]), end = as.numeric(res_df[, 2]), names = data_rest),
strand = S4Vectors::Rle(rep("*", nrow(res_df))))
}
else {
res_gr &lt;- NULL
}
if (!is.null(gr_SNP)) {
if (!is.null(res_gr)) {
gr_SNP &lt;- c(gr_SNP, res_gr)
}
}
else {
if (!is.null(res_gr)) {
gr_SNP &lt;- res_gr
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tOut of %d input SNPs, %d SNPs have positional
info",
length(data), length(gr_SNP)), appendLF = T)
}
if (!is.null(gr_SNP)) {
tmp_df &lt;- GenomicRanges::as.data.frame(gr_SNP, row.names = NULL)
mcols_df &lt;- data.frame(variant_id = paste(tmp_df[, 1],
":", tmp_df[, 3], sep = ""), stringsAsFactors = F)
GenomicRanges::mcols(gr_SNP) &lt;- mcols_df
}
invisible(gr_SNP)
}
</pre>


</body></html>
