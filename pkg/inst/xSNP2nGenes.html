<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xSNP2nGenes"><tr><td>xSNP2nGenes</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xSNP2nGenes</h2>

<h3>Usage</h3>

<pre>
xSNP2nGenes(data, distance.max = 2e+05, decay.kernel = c("rapid",
"slow", "linear", "constant"), decay.exponent = 2, GR.SNP =
c("dbSNP_GWAS", "dbSNP_Common", "dbSNP_Single"), GR.Gene =
c("UCSC_knownGene", "UCSC_knownCanonical"), include.TAD = c("none",
"GM12878", "IMR90", "MSC", "TRO", "H1", "MES", "NPC"), verbose = T,
RData.location = "http://galahad.well.ox.ac.uk/bigdata", guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>distance.max</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>decay.kernel</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>decay.exponent</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.SNP</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.Gene</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>include.TAD</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, distance.max = 2e+05, decay.kernel = c("rapid",
"slow", "linear", "constant"), decay.exponent = 2, GR.SNP =
c("dbSNP_GWAS",
"dbSNP_Common", "dbSNP_Single"), GR.Gene = c("UCSC_knownGene",
"UCSC_knownCanonical"), include.TAD = c("none", "GM12878",
"IMR90", "MSC", "TRO", "H1", "MES", "NPC"), verbose = T,
RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
decay.kernel &lt;- match.arg(decay.kernel)
include.TAD &lt;- match.arg(include.TAD)
data &lt;- gsub("_", ":", data, perl = T)
data &lt;- gsub("imm:", "chr", data, perl = T)
data &lt;- unique(data)
gr_SNP &lt;- xSNPlocations(data = data, GR.SNP = GR.SNP, verbose =
verbose,
RData.location = RData.location, guid = guid)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Load positional information for Genes (%s) ...",
as.character(now)), appendLF = T)
}
if (class(GR.Gene) == "GRanges") {
gr_Gene &lt;- GR.Gene
}
else {
gr_Gene &lt;- xRDataLoader(GR.Gene[1], verbose = verbose,
RData.location = RData.location, guid = guid)
if (is.null(gr_Gene)) {
GR.Gene &lt;- "UCSC_knownGene"
if (verbose) {
message(sprintf("Instead, %s will be used", GR.Gene),
appendLF = T)
}
gr_Gene &lt;- xRDataLoader(GR.Gene, verbose = verbose,
RData.location = RData.location, guid = guid)
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Define nearby genes (%s) ...", as.character(now)),
appendLF = T)
}
maxgap &lt;- distance.max - 1
minoverlap &lt;- 0L
subject &lt;- gr_Gene
query &lt;- gr_SNP
q2r &lt;-
as.matrix(as.data.frame(suppressWarnings(GenomicRanges::findOverlaps(query
= query,
subject = subject, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = T))))
if (length(q2r) &gt; 0) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Calculate distance (%s) ...", as.character(now)),
appendLF = T)
}
if (1) {
x &lt;- subject[q2r[, 2], ]
y &lt;- query[q2r[, 1], ]
dists &lt;- GenomicRanges::distance(x, y, select = "all",
ignore.strand = T)
df_y &lt;- GenomicRanges::as.data.frame(y, row.names = NULL)
df_x &lt;- GenomicRanges::as.data.frame(x, row.names = NULL)
if (0) {
df_interval &lt;- data.frame(seqnames = df_y$seqnames,
start = df_y$start, end = df_y$end, stringsAsFactors = FALSE)
ind &lt;- df_y$start &lt; df_x$start
df_interval[ind, ] &lt;- data.frame(seqnames = df_y$seqnames[ind],
start = df_y$start[ind], end = df_x$start[ind],
stringsAsFactors = FALSE)
ind &lt;- df_y$start &gt; df_x$end
df_interval[ind, ] &lt;- data.frame(seqnames = df_y$seqnames[ind],
start = df_x$end[ind], end = df_y$start[ind],
stringsAsFactors = FALSE)
}
else {
df_interval &lt;- data.frame(seqnames = df_y$seqnames,
start = df_y$start, end = df_y$end, stringsAsFactors = FALSE)
ind &lt;- df_x$strand == "+"
df_interval[ind, ] &lt;- data.frame(seqnames = df_y$seqnames[ind],
start = df_y$start[ind], end = df_x$start[ind],
stringsAsFactors = FALSE)
ind &lt;- df_x$strand == "-"
df_interval[ind, ] &lt;- data.frame(seqnames = df_y$seqnames[ind],
start = df_y$start[ind], end = df_x$end[ind],
stringsAsFactors = FALSE)
ind &lt;- df_x$strand == "*"
df_interval[ind, ] &lt;- data.frame(seqnames = df_y$seqnames[ind],
start = df_y$start[ind], end = (df_x$start[ind] +
df_x$end[ind])/2, stringsAsFactors = FALSE)
ind &lt;- df_interval$start &gt; df_interval$end
df_interval[ind, ] &lt;- data.frame(seqnames = df_interval$seqnames[ind],
start = df_interval$end[ind], end = df_interval$start[ind],
stringsAsFactors = FALSE)
}
df_interval[dists == 0, "start"] &lt;- df_y$start[dists ==
0]
df_interval[dists == 0, "end"] &lt;- df_y$end[dists ==
0]
vec_interval &lt;- paste0(df_interval$seqnames, ":",
as.character(df_interval$start), "-", as.character(df_interval$end))
df_nGenes &lt;- data.frame(Gene = names(x), SNP = names(y),
Dist = dists, Gap = vec_interval, stringsAsFactors = F)
}
if (distance.max == 0) {
x &lt;- df_nGenes$Dist
}
else {
x &lt;- df_nGenes$Dist/distance.max
}
if (decay.kernel == "slow") {
y &lt;- 1 - (x)^decay.exponent
}
else if (decay.kernel == "rapid") {
y &lt;- (1 - x)^decay.exponent
}
else if (decay.kernel == "linear") {
y &lt;- 1 - x
}
else {
y &lt;- 1
}
df_nGenes$Weight &lt;- y
if (verbose) {
now &lt;- Sys.time()
message(sprintf("%d Genes are defined as nearby genes within %d(bp)
genomic distance window using '%s' decay kernel (%s)",
length(unique(df_nGenes$Gene)), distance.max,
decay.kernel, as.character(now)), appendLF = T)
}
df_nGenes &lt;- df_nGenes[, c("Gene", "SNP", "Dist", "Weight",
"Gap")]
df_nGenes &lt;- df_nGenes[order(df_nGenes$Gene, df_nGenes$Dist,
decreasing = FALSE), ]
}
else {
df_nGenes &lt;- NULL
if (verbose) {
now &lt;- Sys.time()
message(sprintf("No nearby genes are defined"), appendLF = T)
}
}
default.include.TAD &lt;- c("GM12878", "IMR90", "MSC", "TRO",
"H1", "MES", "MES")
ind &lt;- match(default.include.TAD, include.TAD)
include.TAD &lt;- default.include.TAD[!is.na(ind)]
if (length(include.TAD) &gt; 0) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Inclusion of TAD boundary regions is based on '%s'",
include.TAD), appendLF = T)
}
df_nGenes$TAD &lt;- rep("Excluded", nrow(df_nGenes))
TAD &lt;- xRDataLoader(paste0("TAD.", include.TAD), RData.location =
RData.location,
guid = guid, verbose = verbose)
iGR &lt;- xGR(data = df_nGenes$Gap, format = "chr:start-end",
RData.location = RData.location, guid = guid)
q2r &lt;-
as.matrix(as.data.frame(suppressWarnings(GenomicRanges::findOverlaps(query
= iGR,
subject = TAD, type = "within", select = "all", ignore.strand = T))))
q2r &lt;- q2r[!duplicated(q2r[, 1]), ]
df_nGenes$TAD[q2r[, 1]] &lt;- GenomicRanges::mcols(TAD)[q2r[,
2], ]
df_nGenes$TAD[df_nGenes$Dist == 0] &lt;- df_nGenes$Gap[df_nGenes$Dist ==
0]
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\t%d out of %d SNP-nGene pairs are within the same
TAD boundary regions",
sum(df_nGenes$TAD != "Excluded"), length(iGR)),
appendLF = T)
message(sprintf("\t%d out of %d genes are defined as nearby genes
after considering TAD boundary regions",
length(unique(df_nGenes[df_nGenes$TAD != "Excluded",
"Gene"])), length(unique(df_nGenes$Gene))),
appendLF = T)
}
}
if (!is.null(df_nGenes)) {
ind &lt;- xSymbol2GeneID(df_nGenes$Gene, details = FALSE,
verbose = verbose, RData.location = RData.location,
guid = guid)
df_nGenes &lt;- df_nGenes[!is.na(ind), ]
if (nrow(df_nGenes) == 0) {
df_nGenes &lt;- NULL
}
}
invisible(df_nGenes)
}
</pre>


</body></html>
