<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xDefineHIC"><tr><td>xDefineHIC</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xDefineHIC</h2>

<h3>Usage</h3>

<pre>
xDefineHIC(data = NULL, entity = c("SNP", "chr:start-end",
"data.frame", "bed", "GRanges"), include.HiC = c(NA, "Monocytes",
"Macrophages_M0", "Macrophages_M1", "Macrophages_M2", "Neutrophils",
"Megakaryocytes", "Endothelial_precursors", "Erythroblasts",
"Fetal_thymus", "Naive_CD4_T_cells", "Total_CD4_T_cells",
"Activated_total_CD4_T_cells", "Nonactivated_total_CD4_T_cells",
"Naive_CD8_T_cells", "Total_CD8_T_cells", "Naive_B_cells",
"Total_B_cells", "PE.Monocytes", "PE.Macrophages_M0",
"PE.Macrophages_M1", "PE.Macrophages_M2", "PE.Neutrophils",
"PE.Megakaryocytes", "PE.Erythroblasts", "PE.Naive_CD4_T_cells",
"PE.Naive_CD8_T_cells", "Combined", "Combined_PE"), GR.SNP =
c("dbSNP_GWAS", "dbSNP_Common", "dbSNP_Single"), verbose = TRUE,
RData.location = "http://galahad.well.ox.ac.uk/bigdata", guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>entity</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>include.HiC</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.SNP</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data = NULL, entity = c("SNP", "chr:start-end", "data.frame",
"bed", "GRanges"), include.HiC = c(NA, "Monocytes", "Macrophages_M0",
"Macrophages_M1", "Macrophages_M2", "Neutrophils", "Megakaryocytes",
"Endothelial_precursors", "Erythroblasts", "Fetal_thymus",
"Naive_CD4_T_cells", "Total_CD4_T_cells",
"Activated_total_CD4_T_cells",
"Nonactivated_total_CD4_T_cells", "Naive_CD8_T_cells",
"Total_CD8_T_cells",
"Naive_B_cells", "Total_B_cells", "PE.Monocytes", "PE.Macrophages_M0",
"PE.Macrophages_M1", "PE.Macrophages_M2", "PE.Neutrophils",
"PE.Megakaryocytes", "PE.Erythroblasts", "PE.Naive_CD4_T_cells",
"PE.Naive_CD8_T_cells", "Combined", "Combined_PE"), GR.SNP =
c("dbSNP_GWAS",
"dbSNP_Common", "dbSNP_Single"), verbose = TRUE, RData.location =
"http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
entity &lt;- match.arg(entity)
default.include.HiC &lt;- c("Monocytes", "Macrophages_M0",
"Macrophages_M1",
"Macrophages_M2", "Neutrophils", "Megakaryocytes",
"Endothelial_precursors",
"Erythroblasts", "Fetal_thymus", "Naive_CD4_T_cells",
"Total_CD4_T_cells", "Activated_total_CD4_T_cells",
"Nonactivated_total_CD4_T_cells",
"Naive_CD8_T_cells", "Total_CD8_T_cells", "Naive_B_cells",
"Total_B_cells", "PE.Monocytes", "PE.Macrophages_M0",
"PE.Macrophages_M1", "PE.Macrophages_M2", "PE.Neutrophils",
"PE.Megakaryocytes", "PE.Erythroblasts", "PE.Naive_CD4_T_cells",
"PE.Naive_CD8_T_cells", "Combined", "Combined_PE")
ind &lt;- match(default.include.HiC, include.HiC)
include.HiC &lt;- default.include.HiC[!is.na(ind)]
if (!is.null(data)) {
if (entity == "SNP") {
data_gr &lt;- xSNPlocations(data, GR.SNP = GR.SNP, verbose = verbose,
RData.location = RData.location, guid = guid)
}
else {
data_gr &lt;- xGR(data, format = entity, verbose = verbose,
RData.location = RData.location, guid = guid)
}
if (is.null(data_gr)) {
return(NULL)
}
}
df_returned &lt;- NULL
if (length(include.HiC) &gt; 0) {
res_list &lt;- lapply(include.HiC, function(x) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Processing %s ...", x), appendLF = TRUE)
}
if (x == "Combined") {
g &lt;- xRDataLoader(RData.customised = "ig.PCHiC",
RData.location = RData.location, guid = guid,
verbose = verbose)
df &lt;- do.call(cbind, igraph::edge_attr(g))
if (1) {
df[df &lt; 5] &lt;- NA
res &lt;- xAggregate(log(df), verbose = FALSE)
vec_score &lt;- res$Aggregate
}
else {
num &lt;- apply(df &gt;= 5, 1, sum)
dff &lt;- df
dff[dff &lt; 5] &lt;- 0
total &lt;- apply(dff, 1, sum)
ave &lt;- log(total/num)
ave_scale &lt;- (ave - min(ave))/(max(ave) - min(ave)) *
0.9999999
vec_score &lt;- num + ave_scale
}
ig &lt;- g
E(ig)$score &lt;- vec_score
for (i in igraph::edge_attr_names(g)) {
ig &lt;- igraph::delete_edge_attr(ig, i)
}
}
else if (x == "Combined_PE") {
g &lt;- xRDataLoader(RData.customised = "ig.PCHiC_PE",
RData.location = RData.location, guid = guid,
verbose = verbose)
df &lt;- do.call(cbind, igraph::edge_attr(g))
if (1) {
df[df &lt; 5] &lt;- NA
res &lt;- xAggregate(log(df), verbose = FALSE)
vec_score &lt;- res$Aggregate
}
else {
num &lt;- apply(df &gt;= 5, 1, sum)
dff &lt;- df
dff[dff &lt; 5] &lt;- 0
total &lt;- apply(dff, 1, sum)
ave &lt;- log(total/num)
ave_scale &lt;- (ave - min(ave))/(max(ave) - min(ave)) *
0.9999999
vec_score &lt;- num + ave_scale
}
ig &lt;- g
E(ig)$score &lt;- vec_score
for (i in igraph::edge_attr_names(g)) {
ig &lt;- igraph::delete_edge_attr(ig, i)
}
}
else {
if (sum(grep("^PE.", x, perl = TRUE)) &gt; 0) {
RData.customised &lt;- paste("ig.PCHiC_", x, sep = "")
}
else {
RData.customised &lt;- paste("ig.PCHiC.", x, sep = "")
}
ig &lt;- xRDataLoader(RData.customised = RData.customised,
RData.location = RData.location, guid = guid,
verbose = verbose)
}
df_nodes &lt;- igraph::get.data.frame(ig, what = "vertices")
df_edges &lt;- igraph::get.data.frame(ig, what = "edges")
if (!is.null(data)) {
nodes_gr &lt;- xGR(data = df_nodes[, 1], format = "chr:start-end",
verbose = verbose, RData.location = RData.location,
guid = guid)
maxgap &lt;- -1L
minoverlap &lt;- 0L
subject &lt;- nodes_gr
query &lt;- data_gr
q2r &lt;- as.matrix(as.data.frame(GenomicRanges::findOverlaps(query =
query,
subject = subject, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = TRUE)))
res_df &lt;- data.frame(SNP = names(data_gr)[q2r[,
1]], nodes = names(nodes_gr)[q2r[, 2]], stringsAsFactors = FALSE)
ind_from &lt;- match(res_df$nodes, df_edges[, "from"])
nodes_from &lt;- res_df[!is.na(ind_from), ]
partner_from &lt;- df_edges[ind_from[!is.na(ind_from)],
c("to", "score")]
partner_from_gene &lt;- df_nodes[match(partner_from[,
1], df_nodes[, 1]), 2]
nodes_from_gene &lt;- df_nodes[match(nodes_from[,
2], df_nodes[, 1]), 2]
df_from &lt;- cbind(nodes_from, partner_from, nodes_from_gene,
partner_from_gene, stringsAsFactors = FALSE)
colnames(df_from) &lt;- c("SNP", "harbor", "partner",
"score", "harbor_genes", "partner_genes")
df_from$harbor_end &lt;- rep("bait/from", nrow(df_from))
ind_to &lt;- match(res_df$nodes, df_edges[, "to"])
nodes_to &lt;- res_df[!is.na(ind_to), ]
partner_to &lt;- df_edges[ind_to[!is.na(ind_to)],
c("from", "score")]
partner_to_gene &lt;- df_nodes[match(partner_to[,
1], df_nodes[, 1]), 2]
nodes_to_gene &lt;- df_nodes[match(nodes_to[, 2],
df_nodes[, 1]), 2]
df_to &lt;- cbind(nodes_to, partner_to, nodes_to_gene,
partner_to_gene, stringsAsFactors = FALSE)
colnames(df_to) &lt;- c("SNP", "harbor", "partner",
"score", "harbor_genes", "partner_genes")
df_to$harbor_end &lt;- rep("prey/to", nrow(df_to))
df &lt;- rbind(df_from, df_to)
df$Context &lt;- rep(x, nrow(df))
y &lt;- df
ind &lt;- which(y$harbor_end == "bait/from")
df_bait &lt;- y[ind, c("harbor", "partner", "score",
"harbor_genes", "partner_genes", "SNP", "harbor_end",
"harbor", "Context")]
colnames(df_bait) &lt;- c("from", "to", "score",
"from_genes", "to_genes", "SNP", "SNP_end",
"SNP_harbor", "Context")
ind &lt;- which(y$harbor_end == "prey/to")
df_prey &lt;- y[ind, c("partner", "harbor", "score",
"partner_genes", "harbor_genes", "SNP", "harbor_end",
"harbor", "Context")]
colnames(df_prey) &lt;- c("from", "to", "score",
"from_genes", "to_genes", "SNP", "SNP_end",
"SNP_harbor", "Context")
df &lt;- rbind(df_bait, df_prey)
rownames(df) &lt;- NULL
}
else {
df &lt;- df_edges
colnames(df) &lt;- c("from", "to", "score")
df$Context &lt;- rep(x, nrow(df))
}
return(df)
})
df_returned &lt;- do.call(rbind, res_list)
}
if (!is.null(data) &amp; !is.null(df_returned)) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Amongst %d SNPs, %d SNPs are falling into %d
interacton regions",
length(unique(data)), length(unique(df_returned$SNP)),
length(unique(df_returned$SNP_harbor))), appendLF = TRUE)
}
context_ls &lt;- split(x = df_returned, f = df_returned$Context)
ls_ig &lt;- lapply(1:length(context_ls), function(i) {
df &lt;- context_ls[[i]]
if (1) {
res_ls &lt;- lapply(split(x = df$SNP, f = df$SNP_harbor),
function(x) {
paste(x, collapse = ";")
})
vec_harbor_SNPs &lt;- unlist(res_ls)
relations &lt;- df[, 1:3]
relations &lt;- relations[!duplicated(relations),
]
nodes &lt;- base::as.data.frame(rbind(as.matrix(df[,
c("from", "from_genes")]), as.matrix(df[, c("to",
"to_genes")])), stringsAsFactors = FALSE)
nodes &lt;- nodes[!duplicated(nodes), ]
colnames(nodes) &lt;- c("name", "target")
nodes$SNP &lt;- NA
ind &lt;- match(nodes$name, names(vec_harbor_SNPs))
nodes$SNP[!is.na(ind)] &lt;- vec_harbor_SNPs[ind[!is.na(ind)]]
ig &lt;- graph.data.frame(d = relations, directed = TRUE,
vertices = nodes)
class(ig) &lt;- c("PCHiC", "igraph")
return(ig)
}
})
names(ls_ig) &lt;- names(context_ls)
if (length(ls_ig) == 1) {
ls_ig &lt;- ls_ig[[1]]
}
output &lt;- list(df = df_returned, ig = ls_ig)
}
else {
output &lt;- df_returned
}
invisible(output)
}
</pre>


</body></html>
