<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xDAGpropagate"><tr><td>xDAGpropagate</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xDAGpropagate</h2>

<h3>Usage</h3>

<pre>
xDAGpropagate(g, annotation, path.mode = c("all_paths",
"shortest_paths", "all_shortest_paths"), propagation = c("all", "min",
"max"), verbose = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>g</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>annotation</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>propagation</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (g, annotation, path.mode = c("all_paths", "shortest_paths",
"all_shortest_paths"), propagation = c("all", "min", "max"),
verbose = TRUE)
{
path.mode &lt;- match.arg(path.mode)
propagation &lt;- match.arg(propagation)
ig &lt;- g
if (class(ig) != "igraph") {
stop("The function must apply to the 'igraph' object.\n")
}
if (class(annotation) == "list") {
oAnnos &lt;- annotation
}
else {
if (class(annotation) == "data.frame") {
annotation &lt;- xSparseMatrix(annotation, verbose = FALSE)
}
if (class(annotation) == "dgCMatrix") {
D &lt;- annotation
oAnnos &lt;- lapply(1:ncol(D), function(j) {
ind &lt;- which(D[, j] != 0)
x &lt;- D[ind, j]
names(x) &lt;- names(ind)
x
})
names(oAnnos) &lt;- colnames(annotation)
}
else {
stop("The input annotation must be either 'GS' or 'list' or 'dgCMatrix'
object.\n")
}
}
if (is.list(oAnnos)) {
originNodes &lt;- names(oAnnos)
ind &lt;- match(originNodes, V(ig)$name)
nodes_mapped &lt;- originNodes[!is.na(ind)]
if (length(nodes_mapped) == 0) {
stop("The input annotation data do not contain terms matched to the
nodes/terms in the input graph.\n")
}
}
dag &lt;- dnet::dDAGinduce(ig, originNodes, path.mode = path.mode)
allNodes &lt;- V(dag)$name
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Do propagation via '%s' operation (%s) ...",
propagation, as.character(now)), appendLF = T)
}
if (1) {
pAnnos &lt;- oAnnos[allNodes]
names(pAnnos) &lt;- allNodes
level2node &lt;- dnet::dDAGlevel(dag, level.mode = "longest_path",
return.mode = "level2node")
nLevels &lt;- length(level2node)
for (i in nLevels:2) {
currNodes &lt;- level2node[[i]]
adjNodesList &lt;- lapply(currNodes, function(node) {
neighs.in &lt;- igraph::neighborhood(dag, order = 1,
nodes = node, mode = "in")
setdiff(V(dag)[unlist(neighs.in)]$name, node)
})
names(adjNodesList) &lt;- currNodes
for (k in 1:length(currNodes)) {
node &lt;- currNodes[k]
nowDomain &lt;- pAnnos[[node]]
nowDomain_mat &lt;- cbind(names(nowDomain), as.numeric(nowDomain))
adjNodes &lt;- adjNodesList[[node]]
res &lt;- lapply(adjNodes, function(adjNode) {
adjDomain &lt;- pAnnos[[adjNode]]
adjDomain_mat &lt;- cbind(names(adjDomain), as.numeric(adjDomain))
all_mat &lt;- rbind(nowDomain_mat, adjDomain_mat)
all_list &lt;- base::split(x = as.numeric(all_mat[,
2]), f = all_mat[, 1])
output_list &lt;- lapply(1:length(all_list), function(i) {
x &lt;- all_list[[i]]
if (propagation == "max") {
y &lt;- max(x)
}
else if (propagation == "min") {
y &lt;- min(x)
}
else {
y &lt;- unique(x)
}
data.frame(name = rep(names(all_list)[i],
length(y)), value = y, stringsAsFactors = FALSE)
})
if (0) {
x_mat &lt;- base::do.call(base::rbind, output_list)
output &lt;- as.vector(x_mat)
names(output) &lt;- rownames(x_mat)
}
else {
x_mat &lt;- base::do.call(base::rbind, output_list)
output &lt;- x_mat$value
names(output) &lt;- x_mat$name
}
return(output)
})
pAnnos[adjNodes] &lt;- res
}
if (verbose) {
message(sprintf("\tAt level %d, there are %d nodes, and %d incoming
neighbors (%s).",
i, length(currNodes), length(unique(unlist(adjNodesList))),
as.character(Sys.time())), appendLF = T)
}
}
}
ind &lt;- match(V(dag)$name, names(pAnnos))
V(dag)$anno &lt;- pAnnos[ind]
counts &lt;- sapply(V(dag)$anno, length)
IC &lt;- -1 * log10(counts/max(counts))
if (1) {
IC[is.infinite(IC)] &lt;- 0
}
V(dag)$IC &lt;- IC
return(dag)
}
</pre>


</body></html>
