<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xEnrichChord"><tr><td>xEnrichChord</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xEnrichChord</h2>

<h3>Usage</h3>

<pre>
xEnrichChord(eTerm, top_num = 5, FDR.cutoff = 0.05, colormap.group =
"ggplot2", colormap.ontology = NULL, wrap.width = NULL, text.size =
0.6, legend = NULL, vline = F, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>eTerm</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>top_num</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>FDR.cutoff</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>colormap.group</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>colormap.ontology</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>wrap.width</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>text.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>legend</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>vline</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (eTerm, top_num = 5, FDR.cutoff = 0.05, colormap.group =
"ggplot2",
colormap.ontology = NULL, wrap.width = NULL, text.size = 0.6,
legend = NULL, vline = F, ...)
{
if (is.null(eTerm)) {
warnings("There is no enrichment in the 'eTerm' object.\n")
return(NULL)
}
if (class(eTerm) == "eTerm") {
df &lt;- xEnrichViewer(eTerm, top_num = "all")
if (top_num == "auto") {
top_num &lt;- sum(df$adjp &lt; FDR.cutoff)
if (top_num &lt;= 1) {
top_num &lt;- 10
}
}
df &lt;- xEnrichViewer(eTerm, top_num = top_num, sortBy = "adjp")
df$group &lt;- "group"
df$ontology &lt;- "ontology"
}
else if (class(eTerm) == "ls_eTerm" | class(eTerm) == "data.frame") {
if (class(eTerm) == "ls_eTerm") {
df &lt;- eTerm$df[, c("group", "ontology", "name", "adjp",
"zscore")]
}
else if (class(eTerm) == "data.frame") {
if (all(c("group", "ontology", "name", "adjp", "zscore") %in%
colnames(eTerm))) {
df &lt;- eTerm[, c("group", "ontology", "name",
"adjp", "zscore")]
}
else if (all(c("group", "name", "adjp", "zscore") %in%
colnames(eTerm))) {
df &lt;- eTerm[, c("group", "name", "adjp", "zscore")]
df$ontology &lt;- "ontology"
}
else if (all(c("ontology", "name", "adjp", "zscore") %in%
colnames(eTerm))) {
df &lt;- eTerm[, c("ontology", "name", "adjp", "zscore")]
df$group &lt;- "group"
}
else if (all(c("name", "adjp", "zscore") %in% colnames(eTerm))) {
df &lt;- eTerm[, c("name", "adjp", "zscore")]
df$group &lt;- "group"
df$ontology &lt;- "ontology"
}
else {
warnings("The input data.frame does not contain required columns:
c('group','ontology','name','adjp','zscore').\n")
return(NULL)
}
}
group &lt;- ontology &lt;- rank &lt;- adjp &lt;- NULL
df &lt;- df %&gt;% dplyr::arrange(adjp)
if (top_num == "auto") {
df &lt;- subset(df, df$adjp &lt; FDR.cutoff)
}
else {
top_num &lt;- as.integer(top_num)
df &lt;- as.data.frame(df %&gt;% dplyr::group_by(group,
ontology) %&gt;% dplyr::group_by(rank = rank(adjp),
add = TRUE) %&gt;% dplyr::filter(rank &lt;= top_num &amp;
adjp &lt; FDR.cutoff))
}
}
if (!is.null(wrap.width)) {
width &lt;- as.integer(wrap.width)
res_list &lt;- lapply(df$name, function(x) {
x &lt;- gsub("_", " ", x)
y &lt;- strwrap(x, width = width)
if (length(y) &gt; 1) {
paste(y, collapse = "\n")
}
else {
y
}
})
df$name &lt;- unlist(res_list)
}
name &lt;- n &lt;- ontology &lt;- zscore &lt;- group &lt;- NULL
df &lt;- as.data.frame(df %&gt;% dplyr::group_by(name) %&gt;%
dplyr::group_by(n = n(),
add = T) %&gt;% dplyr::arrange(ontology, n, zscore))
order &lt;- c(sort(unique(df$group)), unique(df$name))
if (is.null(colormap.ontology)) {
if (length(table(df$ontology)) == 1) {
colormap.ontology &lt;- "grey-grey"
}
else {
colormap.ontology &lt;- "spectral"
}
}
circlize::circos.clear()
circlize::circos.par(start.degree = 90, clock.wise = FALSE)
tmp &lt;- table(df$group)
color_group &lt;- xColormap(colormap.group)(length(tmp))
names(color_group) &lt;- names(tmp)
tmp &lt;- table(df$ontology)
color_ontology &lt;- xColormap(colormap.ontology)(length(tmp))
names(color_ontology) &lt;- names(tmp)
color_name &lt;- color_ontology[df$ontology]
names(color_name) &lt;- df$name
grid.col &lt;- c(color_group, color_name)
df_data &lt;- df[, c("group", "name", "zscore")]
circlize::chordDiagram(df_data, annotationTrack = "grid",
grid.col = grid.col, preAllocateTracks = 1, ...)
circlize::circos.trackPlotRegion(track.index = 1, panel.fun =
function(x,
y) {
xlim = circlize::get.cell.meta.data("xlim")
ylim = circlize::get.cell.meta.data("ylim")
sector.name = circlize::get.cell.meta.data("sector.index")
circlize::circos.text(mean(xlim), ylim[1] + 0.1, sector.name,
facing = "clockwise", niceFacing = TRUE, adj = c(0,
0.5), cex = text.size)
}, bg.border = NA)
if (vline) {
abline(v = 0, lty = 2, col = "#00000080")
}
if (any((is.null(legend) &amp; length(color_group) &gt; 1), legend)) {
legend("topleft", title = "Groups", legend = names(color_group),
border = color_group, fill = color_group, horiz = F,
box.col = "transparent", cex = text.size)
}
if (any((is.null(legend) &amp; length(color_ontology) &gt; 1), legend)) {
legend("topright", title = "Ontologies", legend =
names(color_ontology),
border = color_ontology, fill = color_ontology, horiz = F,
box.col = "transparent", cex = text.size)
}
invisible(df)
}
</pre>


</body></html>
