<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGGnetwork"><tr><td>xGGnetwork</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGGnetwork</h2>

<h3>Usage</h3>

<pre>
xGGnetwork(g, node.label = NULL, label.wrap.width = NULL,
label.wrap.lineheight = 0.8, node.label.size = NULL,
node.label.fontface = "plain", node.label.color = "darkblue",
node.label.alpha = 0.8, node.label.padding = 1, node.label.arrow =
0.01, node.label.force = 1, node.shape = 19, node.shape.title = NULL,
node.xcoord = NULL, node.ycoord = NULL, node.color = NULL,
node.color.title = NULL, colormap = "grey-orange-darkred", ncolors =
64, zlim = NULL, na.color = "grey80", node.color.alpha = 1, node.size =
NULL, node.size.title = NULL, node.size.range = c(1, 4), slim = NULL,
title = "", edge.size = 0.5, edge.color = "black", edge.color.alpha =
0.5, edge.curve = 0.1, edge.arrow = 2, edge.arrow.gap = 0.02, ncolumns
= NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>g</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>label.wrap.width</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>label.wrap.lineheight</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.fontface</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.alpha</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.padding</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.arrow</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.label.force</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.shape</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.shape.title</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.xcoord</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.ycoord</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.color.title</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>colormap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ncolors</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>zlim</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>na.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.color.alpha</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.size.title</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>node.size.range</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>slim</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>title</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.size</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.color</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.color.alpha</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.curve</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.arrow</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>edge.arrow.gap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ncolumns</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (g, node.label = NULL, label.wrap.width = NULL,
label.wrap.lineheight = 0.8,
node.label.size = NULL, node.label.fontface = "plain", node.label.color
= "darkblue",
node.label.alpha = 0.8, node.label.padding = 1, node.label.arrow =
0.01,
node.label.force = 1, node.shape = 19, node.shape.title = NULL,
node.xcoord = NULL, node.ycoord = NULL, node.color = NULL,
node.color.title = NULL, colormap = "grey-orange-darkred",
ncolors = 64, zlim = NULL, na.color = "grey80", node.color.alpha = 1,
node.size = NULL, node.size.title = NULL, node.size.range = c(1,
4), slim = NULL, title = "", edge.size = 0.5, edge.color = "black",
edge.color.alpha = 0.5, edge.curve = 0.1, edge.arrow = 2,
edge.arrow.gap = 0.02, ncolumns = NULL)
{
if (any(class(g) %in% c("igraph"))) {
ls_ig &lt;- list(g)
}
else if (class(g) == "list") {
ls_ig &lt;- base::Filter(base::Negate(is.null), g)
if (length(ls_ig) == 0) {
return(NULL)
}
}
else {
stop("The function must apply to 'list' of 'igraph' objects or a
'igraph' object.\n")
}
ls_names &lt;- names(ls_ig)
if (is.null(ls_names)) {
ls_names &lt;- paste("IG", 1:length(ls_ig), sep = "_")
names(ls_ig) &lt;- ls_names
}
ls_df &lt;- lapply(1:length(ls_ig), function(i) {
ig &lt;- ls_ig[[i]]
if (igraph::vcount(ig) == 0) {
return(NULL)
}
if (is.null(V(ig)$name)) {
V(ig)$name &lt;- 1:vcount(ig)
}
node_attrs &lt;- igraph::vertex_attr_names(ig)
for (k in 1:length(node_attrs)) {
if (class(igraph::vertex_attr(ig, node_attrs[k])) ==
"list") {
ig &lt;- ig %&gt;% igraph::delete_vertex_attr(node_attrs[k])
}
}
nnode &lt;- igraph::vcount(ig)
if (length(node.xcoord) != nnode | length(node.ycoord) !=
nnode) {
if (!is.null(node.xcoord)) {
node.xcoord &lt;- igraph::vertex_attr(ig, node.xcoord)
}
if (!is.null(node.ycoord)) {
node.ycoord &lt;- igraph::vertex_attr(ig, node.ycoord)
}
if (is.null(node.xcoord) | is.null(node.ycoord)) {
glayout &lt;- igraph::layout_as_tree(ig, root = dnet::dDAGroot(ig),
circular = TRUE, flip.y = TRUE)
if (all(is.na(glayout))) {
glayout &lt;- igraph::layout_with_kk(ig)
}
glayout &lt;- glayout[, c(2:1)]
node.xcoord &lt;- glayout[, 1]
node.ycoord &lt;- glayout[, 2]
}
}
if (max(node.xcoord) != min(node.xcoord)) {
node.xcoord &lt;- (node.xcoord - min(node.xcoord))/(max(node.xcoord) -
min(node.xcoord)) * 2 - 1
}
if (max(node.ycoord) != min(node.ycoord)) {
node.ycoord &lt;- (node.ycoord - min(node.ycoord))/(max(node.ycoord) -
min(node.ycoord)) * 2 - 1
}
if (length(node.label) != nnode) {
if (!is.null(node.label)) {
node.label &lt;- igraph::vertex_attr(ig, node.label)
}
if (is.null(node.label)) {
node.label &lt;- rep("", nnode)
}
}
if (!is.null(label.wrap.width)) {
width &lt;- as.integer(label.wrap.width)
res_list &lt;- lapply(node.label, function(x) {
if (!is.na(x)) {
x &lt;- gsub("_", " ", x)
y &lt;- strwrap(x, width = width)
if (length(y) == 2) {
paste(y, collapse = "\n")
}
else if (length(y) &gt; 2) {
paste0(paste(y[1:2], collapse = "\n"), "...")
}
else {
y
}
}
else {
x
}
})
node.label &lt;- unlist(res_list)
}
V(ig)$n.label &lt;- node.label
if (length(node.label.size) != nnode) {
if (!is.null(node.label.size)) {
tmp.node.label.size &lt;- igraph::vertex_attr(ig,
node.label.size)
}
else {
tmp.node.label.size &lt;- rep(0, nnode)
}
if (is.null(tmp.node.label.size)) {
node.label.size &lt;- rep(node.label.size, nnode)
}
else {
node.label.size &lt;- tmp.node.label.size
}
}
V(ig)$n.label.size &lt;- node.label.size
if (length(node.label.fontface) != nnode) {
if (!is.null(node.label.fontface)) {
tmp.node.label.fontface &lt;- igraph::vertex_attr(ig,
node.label.fontface)
}
else {
tmp.node.label.fontface &lt;- rep(0, nnode)
}
if (is.null(tmp.node.label.fontface)) {
node.label.fontface &lt;- rep(node.label.fontface,
nnode)
}
else {
node.label.fontface &lt;- tmp.node.label.fontface
}
}
V(ig)$n.label.fontface &lt;- node.label.fontface
if (length(node.label.color) != nnode) {
if (!is.null(node.label.color)) {
tmp.node.label.color &lt;- igraph::vertex_attr(ig,
node.label.color)
}
else {
tmp.node.label.color &lt;- rep(0, nnode)
}
if (is.null(tmp.node.label.color)) {
node.label.color &lt;- rep(node.label.color, nnode)
}
else {
node.label.color &lt;- tmp.node.label.color
}
}
V(ig)$n.label.color &lt;- node.label.color
if (length(node.color) != nnode) {
if (!is.null(node.color)) {
node.color &lt;- igraph::vertex_attr(ig, node.color)
}
if (is.null(node.color)) {
node.color &lt;- rep(0, nnode)
}
}
if (is.null(zlim)) {
zlim &lt;- c(min(node.color), max(node.color))
}
node.color[node.color &lt;= zlim[1]] &lt;- zlim[1]
node.color[node.color &gt;= zlim[2]] &lt;- zlim[2]
V(ig)$n.color &lt;- node.color
if (length(node.size) != nnode) {
if (!is.null(node.size)) {
tmp.node.size &lt;- igraph::vertex_attr(ig, node.size)
}
else {
tmp.node.size &lt;- rep(0, nnode)
}
if (is.null(tmp.node.size)) {
node.size &lt;- rep(node.size, nnode)
}
else {
node.size &lt;- tmp.node.size
}
}
if (is.null(slim)) {
slim &lt;- c(min(node.size), max(node.size))
}
node.size[node.size &lt;= slim[1]] &lt;- slim[1]
node.size[node.size &gt;= slim[2]] &lt;- slim[2]
V(ig)$n.size &lt;- node.size
if (length(node.shape) != nnode) {
if (!is.null(node.shape)) {
tmp.node.shape &lt;- igraph::vertex_attr(ig, node.shape)
}
else {
tmp.node.shape &lt;- rep(19, nnode)
}
if (is.null(tmp.node.shape)) {
node.shape &lt;- rep(node.shape, nnode)
}
else {
node.shape &lt;- tmp.node.shape
}
}
V(ig)$n.shape &lt;- node.shape
nedge &lt;- igraph::ecount(ig)
if (length(edge.color) != nedge) {
if (!is.null(edge.color)) {
tmp.edge.color &lt;- igraph::edge_attr(ig, edge.color)
}
else {
tmp.edge.color &lt;- rep("black", nedge)
}
if (is.null(tmp.edge.color)) {
edge.color &lt;- rep(edge.color, nedge)
}
else {
edge.color &lt;- tmp.edge.color
}
}
E(ig)$e.color &lt;- edge.color
if (length(edge.color.alpha) != nedge) {
if (!is.null(edge.color.alpha)) {
tmp.edge.color.alpha &lt;- igraph::edge_attr(ig,
edge.color.alpha)
}
else {
tmp.edge.color.alpha &lt;- rep(0.5, nedge)
}
if (is.null(tmp.edge.color.alpha)) {
edge.color.alpha &lt;- rep(edge.color.alpha, nedge)
}
else {
edge.color.alpha &lt;- tmp.edge.color.alpha
}
}
E(ig)$e.color.alpha &lt;- edge.color.alpha
if (length(edge.size) != nedge) {
if (!is.null(edge.size)) {
tmp.edge.size &lt;- igraph::edge_attr(ig, edge.size)
}
else {
tmp.edge.size &lt;- rep(0.5, nedge)
}
if (is.null(tmp.edge.size)) {
edge.size &lt;- rep(edge.size, nedge)
}
else {
edge.size &lt;- tmp.edge.size
}
}
E(ig)$e.size &lt;- edge.size
gnet &lt;- ggnetwork::ggnetwork(ig, layout = cbind(node.xcoord,
node.ycoord), arrow.gap = edge.arrow.gap, cell.jitter = 0.75)
data.frame(gnet, group = rep(names(ls_ig)[i], nrow(gnet)),
stringsAsFactors = F)
})
df &lt;- do.call(rbind, ls_df)
i &lt;- sapply(df, is.factor)
df[i] &lt;- lapply(df[i], as.character)
df$group &lt;- factor(df$group, levels = names(ls_ig))
df$n.color &lt;- as.numeric(df$n.color)
df$n.size &lt;- as.numeric(df$n.size)
df$n.shape &lt;- factor(df$n.shape, levels = sort(unique(df$n.shape)))
n.color &lt;- n.size &lt;- n.shape &lt;- n.label &lt;- n.label.size &lt;-
n.label.color &lt;- NULL
x &lt;- y &lt;- xend &lt;- yend &lt;- NULL
gp &lt;- ggplot(df, aes(x = x, y = y, xend = xend, yend = yend))
e.color &lt;- subset(df, !is.na(na.y))$e.color
e.color.alpha &lt;- subset(df, !is.na(na.y))$e.color.alpha
e.size &lt;- subset(df, !is.na(na.y))$e.size
if (igraph::is_directed(ls_ig[[1]])) {
gp &lt;- gp + ggnetwork::geom_edges(color = e.color, size = e.size,
alpha = e.color.alpha, curvature = edge.curve, arrow = arrow(length =
unit(edge.arrow,
"pt"), type = "closed"), show.legend = FALSE)
}
else {
gp &lt;- gp + ggnetwork::geom_edges(color = e.color, size = e.size,
alpha = e.color.alpha, curvature = edge.curve, show.legend = FALSE)
}
if (length(unique(df$n.shape)) == 1) {
if (!is.numeric(node.shape)) {
node.shape &lt;- 19
}
gp &lt;- gp + ggnetwork::geom_nodes(aes(color = n.color,
size = n.size), shape = node.shape, alpha = node.color.alpha)
}
else {
gp &lt;- gp + ggnetwork::geom_nodes(aes(color = n.color,
size = n.size, shape = n.shape), alpha = node.color.alpha)
gp &lt;- gp + scale_shape(guide = guide_legend(node.shape.title,
title.position = "top", ncol = 1))
}
if (is.null(node.color.title)) {
node.color.title &lt;- "Node color"
}
if (is.null(zlim)) {
zlim &lt;- range(df$n.color[!is.na(df$n.color)])
}
if (zlim[1] != zlim[2]) {
gp &lt;- gp + scale_colour_gradientn(colors =
xColormap(colormap)(ncolors),
limits = zlim, guide = guide_colorbar(title = node.color.title,
title.position = "top", barwidth = 0.5, nbin = 64,
draw.ulim = FALSE, draw.llim = FALSE), na.value = na.color)
}
else {
gp &lt;- gp + scale_colour_gradientn(colors =
xColormap(colormap)(ncolors),
guide = guide_colorbar(title = node.color.title,
title.position = "top", barwidth = 0.5))
}
if (is.null(node.size.title)) {
node.size.title &lt;- "Node size"
}
if (is.null(slim)) {
slim &lt;- range(df$n.size)
}
if (slim[1] != slim[2]) {
gp &lt;- gp + scale_size_continuous(limits = slim, range =
node.size.range,
guide = guide_legend(node.size.title, title.position = "top",
ncol = 1))
}
else {
gp &lt;- gp + scale_size_continuous(limits = slim, range =
node.size.range,
guide = guide_legend(node.size.title, title.position = "top",
ncol = 1))
}
gp &lt;- gp + ggnetwork::theme_blank()
gp &lt;- gp + theme(text = element_text(family = "sans")) +
labs(title = title) + theme(plot.title = element_text(hjust = 0.5,
size = 10, face = "bold"), plot.margin = unit(rep(0,
4), rep("lines", 4)))
if ((zlim[1] != zlim[2]) &amp; (slim[1] != slim[2])) {
gp &lt;- gp + theme(legend.position = "right")
}
else {
if (slim[1] == slim[2]) {
gp &lt;- gp + guides(size = "none")
}
if (zlim[1] == zlim[2]) {
gp &lt;- gp + guides(color = "none")
}
if (length(unique(df$n.shape)) == 1) {
gp &lt;- gp + guides(shape = "none")
}
}
gp &lt;- gp + theme(legend.title = element_text(size = 8, face = "bold"),
legend.text = element_text(size = 6))
if (length(ls_ig) &gt; 1) {
if (is.null(ncolumns)) {
ncolumns &lt;- ceiling(sqrt(length(ls_ig)))
}
group &lt;- NULL
gp &lt;- gp + facet_wrap(~group, ncol = ncolumns)
gp &lt;- gp + theme(strip.background = element_rect(fill = "transparent",
color = "transparent"), strip.text = element_text(size = 12,
face = "bold"), strip.placement = "inside", panel.spacing = unit(0,
"lines"))
}
if (sum(df$n.label == "") != nrow(df)) {
StatNodes &lt;- ggplot2::ggproto("StatNodes", ggplot2::Stat,
compute_layer = function(data, scales, params) {
if (all(c("xend", "yend") %in% names(data))) {
unique(subset(data, select = c(-xend, -yend)))
}
else {
unique(data)
}
})
my_geom_nodetext_repel &lt;- function(mapping = NULL, data = NULL,
parse = FALSE, ..., box.padding = unit(0.25, "lines"),
point.padding = unit(1e-06, "lines"), segment.size = 0.5,
arrow = NULL, force = 1, max.iter = 2000, nudge_x = 0,
nudge_y = 0, na.rm = FALSE, show.legend = F, inherit.aes = TRUE) {
ggplot2::layer(data = data, mapping = mapping, stat = StatNodes,
geom = ggrepel::GeomTextRepel, position = "identity",
show.legend = show.legend, inherit.aes = inherit.aes,
params = list(parse = parse, na.rm = na.rm, box.padding = box.padding,
point.padding = point.padding, segment.size = segment.size,
arrow = arrow, force = force, max.iter = max.iter,
nudge_x = nudge_x, nudge_y = nudge_y, ...))
}
n.label.size &lt;- subset(df, is.na(na.y))$n.label.size
n.label.fontface &lt;- subset(df, is.na(na.y))$n.label.fontface
n.label.color &lt;- subset(df, is.na(na.y))$n.label.color
gp &lt;- gp + my_geom_nodetext_repel(aes(label = n.label),
lineheight = label.wrap.lineheight, size = n.label.size,
color = n.label.color, fontface = n.label.fontface,
alpha = node.label.alpha, box.padding = unit(0.5,
"lines"), point.padding = unit(node.label.padding,
"lines"), segment.alpha = 0.2, segment.size = 0.2,
arrow = arrow(length = unit(node.label.arrow, "npc")),
force = node.label.force)
}
if (1) {
df &lt;- gp$data
na.y &lt;- NULL
df_sub &lt;- subset(df, is.na(na.y))
ind &lt;- match(colnames(df_sub), c("na.x", "na.y", "e.color",
"edge.color", "e.size"))
df_sub &lt;- df_sub[, is.na(ind)]
df_sub &lt;- df_sub[!duplicated(df_sub), ]
gp$data_nodes &lt;- df_sub
df_sub &lt;- subset(df, !is.na(na.y))
ind &lt;- match(colnames(df_sub), c("x", "y", "xend", "yend",
"e.color", "edge.color", "e.size"))
df_sub &lt;- df_sub[, !is.na(ind)]
df_sub &lt;- df_sub[!duplicated(df_sub), ]
gp$data_edges &lt;- df_sub
}
invisible(gp)
}
</pre>


</body></html>
