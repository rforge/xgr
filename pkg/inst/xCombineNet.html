<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xCombineNet"><tr><td>xCombineNet</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xCombineNet</h2>

<h3>Usage</h3>

<pre>
xCombineNet(list_ig, combineBy = c("union", "intersect"), attrBy =
c("intersect", "union"), keep.all.vertices = FALSE, verbose = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>list_ig</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>combineBy</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>attrBy</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>keep.all.vertices</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (list_ig, combineBy = c("union", "intersect"), attrBy =
c("intersect",
"union"), keep.all.vertices = FALSE, verbose = TRUE)
{
combineBy &lt;- match.arg(combineBy)
attrBy &lt;- match.arg(attrBy)
if (any(class(list_ig) %in% c("igraph"))) {
ls_ig &lt;- list(list_ig)
}
else if (class(list_ig) == "list") {
ls_ig &lt;- base::Filter(base::Negate(is.null), list_ig)
if (length(ls_ig) == 0) {
return(NULL)
}
}
else {
stop("The function must apply to 'list' of 'igraph' objects or a
'igraph' object.\n")
}
flag_direct &lt;- "undirect"
vec &lt;- sapply(ls_ig, igraph::is_directed)
if (sum(vec) == length(vec)) {
flag_direct &lt;- "direct"
}
ls_node_attr &lt;- lapply(1:length(ls_ig), function(i) {
ig &lt;- ls_ig[[i]]
igraph::vertex_attr_names(ig)
})
if (attrBy == "intersect") {
node_attr &lt;- base::Reduce(intersect, ls_node_attr)
}
else if (attrBy == "union") {
node_attr &lt;- base::Reduce(union, ls_node_attr)
}
ls_node &lt;- lapply(1:length(ls_ig), function(i) {
ig &lt;- ls_ig[[i]]
nodes &lt;- igraph::get.data.frame(ig, what = "vertices")[,
node_attr]
})
df_node &lt;- unique(do.call(rbind, ls_node))
if (any(duplicated(df_node$name))) {
name &lt;- NULL
df_node &lt;- df_node[!duplicated(df_node$name), ] %&gt;%
dplyr::select(name)
node_attr &lt;- "name"
}
ls_edge &lt;- lapply(1:length(ls_ig), function(i) {
ig &lt;- ls_ig[[i]]
relations &lt;- igraph::get.data.frame(ig, what = "edges")[,
c(1, 2)]
if (flag_direct == "undirect") {
ind &lt;- which(relations[, 1] &gt; relations[, 2])
relations[ind, c(1:2)] &lt;- relations[ind, c(2, 1)]
relations &lt;- unique(relations)
}
return(relations)
})
df_edge &lt;- do.call(rbind, ls_edge)
if (combineBy == "intersect") {
from &lt;- to &lt;- count &lt;- NULL
ftc &lt;- df_edge %&gt;% dplyr::group_by(from, to) %&gt;%
dplyr::summarize(count = n()) %&gt;%
dplyr::filter(count == length(ls_ig)) %&gt;% dplyr::select(from,
to)
df_edge &lt;- as.data.frame(ftc)
if (!keep.all.vertices) {
tmp_nodes &lt;- unique(c(df_edge[, 1], df_edge[, 2]))
ind &lt;- match(df_node$name, tmp_nodes)
df_node &lt;- df_node[!is.na(ind), ]
}
}
else if (combineBy == "union") {
df_edge &lt;- unique(df_edge)
}
if (flag_direct == "direct") {
combined_ig &lt;- igraph::graph.data.frame(d = df_edge,
directed = TRUE, vertices = df_node)
}
else {
combined_ig &lt;- igraph::graph.data.frame(d = df_edge,
directed = FALSE, vertices = df_node)
}
if (verbose) {
message(sprintf("%d network(s) are combined (via '%s') into a '%s'
network (%d nodes and %d edges) with %d node attributes (via
'%s')",
length(ls_ig), combineBy, flag_direct, vcount(combined_ig),
ecount(combined_ig), length(node_attr), attrBy, appendLF = TRUE))
}
invisible(combined_ig)
}
</pre>


</body></html>
