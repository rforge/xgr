<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xRDataLoader"><tr><td>xRDataLoader</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xRDataLoader</h2>

<h3>Usage</h3>

<pre>
xRDataLoader(RData = c(NA, "GWAS2EF", "GWAS_LD", "IlluminaHumanHT",
"IlluminaOmniExpress", "ig.DO", "ig.EF", "ig.GOBP", "ig.GOCC",
"ig.GOMF", "ig.HPCM", "ig.HPMA", "ig.HPMI", "ig.HPPA", "ig.MP",
"org.Hs.eg", "org.Hs.egDGIdb", "org.Hs.egDO", "org.Hs.egGOBP",
"org.Hs.egGOCC", "org.Hs.egGOMF", "org.Hs.egHPCM", "org.Hs.egHPMA",
"org.Hs.egHPMI", "org.Hs.egHPPA", "org.Hs.egMP", "org.Hs.egMsigdbC1",
"org.Hs.egMsigdbC2BIOCARTA", "org.Hs.egMsigdbC2CGP",
"org.Hs.egMsigdbC2CPall", "org.Hs.egMsigdbC2CP",
"org.Hs.egMsigdbC2KEGG",
"org.Hs.egMsigdbC2REACTOME", "org.Hs.egMsigdbC3MIR",
"org.Hs.egMsigdbC3TFT", "org.Hs.egMsigdbC4CGN", "org.Hs.egMsigdbC4CM",
"org.Hs.egMsigdbC5BP", "org.Hs.egMsigdbC5CC", "org.Hs.egMsigdbC5MF",
"org.Hs.egMsigdbC6", "org.Hs.egMsigdbC7", "org.Hs.egMsigdbH",
"org.Hs.egPS", "org.Hs.egSF", "org.Hs.egPfam", "org.Hs.string",
"org.Hs.PCommons_DN", "org.Hs.PCommons_UN"), RData.customised = NULL,
verbose = T, RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>RData</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.customised</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (RData = c(NA, "GWAS2EF", "GWAS_LD", "IlluminaHumanHT",
"IlluminaOmniExpress", "ig.DO", "ig.EF", "ig.GOBP", "ig.GOCC",
"ig.GOMF", "ig.HPCM", "ig.HPMA", "ig.HPMI", "ig.HPPA", "ig.MP",
"org.Hs.eg", "org.Hs.egDGIdb", "org.Hs.egDO", "org.Hs.egGOBP",
"org.Hs.egGOCC", "org.Hs.egGOMF", "org.Hs.egHPCM", "org.Hs.egHPMA",
"org.Hs.egHPMI", "org.Hs.egHPPA", "org.Hs.egMP", "org.Hs.egMsigdbC1",
"org.Hs.egMsigdbC2BIOCARTA", "org.Hs.egMsigdbC2CGP",
"org.Hs.egMsigdbC2CPall",
"org.Hs.egMsigdbC2CP", "org.Hs.egMsigdbC2KEGG",
"org.Hs.egMsigdbC2REACTOME",
"org.Hs.egMsigdbC3MIR", "org.Hs.egMsigdbC3TFT", "org.Hs.egMsigdbC4CGN",
"org.Hs.egMsigdbC4CM", "org.Hs.egMsigdbC5BP", "org.Hs.egMsigdbC5CC",
"org.Hs.egMsigdbC5MF", "org.Hs.egMsigdbC6", "org.Hs.egMsigdbC7",
"org.Hs.egMsigdbH", "org.Hs.egPS", "org.Hs.egSF", "org.Hs.egPfam",
"org.Hs.string", "org.Hs.PCommons_DN", "org.Hs.PCommons_UN"),
RData.customised = NULL, verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
startT &lt;- Sys.time()
if (verbose) {
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = TRUE)
message("", appendLF = TRUE)
}
RData &lt;- RData[1]
if (is.na(RData) &amp; !is.null(RData.customised)) {
RData &lt;- RData.customised
}
else if (is.na(RData) &amp; is.null(RData.customised)) {
stop("There is no input! Please input one of two parameters ('RData' or
'RData.customised').\n")
}
RData &lt;- gsub(".RData$", "", RData, ignore.case = T, perl = T)
RData &lt;- gsub(".RDa$", "", RData, ignore.case = T, perl = T)
flag_osf &lt;- F
if (!is.null(guid) &amp;&amp; nchar(guid) == 5) {
pkgs &lt;- c("osfr")
if (all(pkgs %in% rownames(utils::installed.packages()))) {
tmp &lt;- sapply(pkgs, function(pkg) {
requireNamespace(pkg, quietly = T)
})
if (all(tmp)) {
if (all(class(suppressWarnings(try(prj &lt;-
osfr::osf_retrieve_node(guid),
T))) != "try-error")) {
target &lt;- paste0(RData, ".RData")
fls &lt;- osfr::osf_ls_files(prj, type = "file",
pattern = target, n_max = Inf)
if (nrow(fls) &gt; 0) {
ind &lt;- match(fls$name, target)
ind &lt;- ind[!is.na(ind)]
if (length(ind) == 1) {
fl &lt;- fls[ind, ]
destfile &lt;- file.path(tempdir(), fl$name)
res &lt;- fl %&gt;% osfr::osf_download(overwrite = T,
path = destfile)
if (file.exists(res$local_path)) {
out &lt;- get(load(res$local_path))
load_RData &lt;- sprintf("'%s' at %s", prj$name,
paste0("https://osf.io/", prj$id))
RData &lt;- target
flag_osf &lt;- T
}
}
}
}
}
}
}
my_https_downloader &lt;- function(url, method = c("auto", "internal",
"wininet", "libcurl", "wget", "curl"), quiet = T, mode = c("w",
"wb", "a", "ab"), cacheOK = T, extra =
getOption("download.file.extra")) {
method &lt;- match.arg(method)
mode &lt;- match.arg(mode)
tdir &lt;- tempdir()
destfile &lt;- file.path(tdir, "temp.RData")
unlink(destfile, recursive = T, force = T)
if (base::grepl("^https?://", url)) {
isR32 &lt;- base::getRversion() &gt;= "3.2"
if (.Platform$OS.type == "windows") {
if (isR32) {
method &lt;- "wininet"
}
else {
seti2 &lt;- utils::"setInternet2"
internet2_start &lt;- seti2(NA)
if (!internet2_start) {
on.exit(suppressWarnings(seti2(internet2_start)))
suppressWarnings(seti2(TRUE))
}
method &lt;- "internal"
}
}
else {
if (isR32 &amp;&amp; capabilities("libcurl")) {
method &lt;- "libcurl"
}
else if (nzchar(Sys.which("wget")[1])) {
method &lt;- "wget"
}
else if (nzchar(Sys.which("curl")[1])) {
method &lt;- "curl"
orig_extra_options &lt;- getOption("download.file.extra")
on.exit(options(download.file.extra = orig_extra_options))
options(download.file.extra = paste("-L", orig_extra_options))
}
else if (nzchar(Sys.which("lynx")[1])) {
method &lt;- "lynx"
}
else {
stop("no download method found")
}
}
}
else {
}
if (class(suppressWarnings(try(utils::download.file(url,
destfile = destfile, method = method, quiet = quiet,
mode = mode, cacheOK = cacheOK, extra = extra), T))) ==
"try-error") {
res_RData &lt;- NULL
res_flag &lt;- F
}
if (file.exists(destfile) &amp; file.info(destfile)$size !=
0) {
if (class(suppressWarnings(try(load(destfile), T))) ==
"try-error") {
res_RData &lt;- NULL
res_flag &lt;- F
}
else {
res_RData &lt;- get(load(destfile))
res_flag &lt;- T
}
}
else {
res_RData &lt;- NULL
res_flag &lt;- F
}
res &lt;- list(RData = res_RData, flag = res_flag)
invisible(res)
}
if (!flag_osf) {
path_host &lt;- gsub("/$", "", RData.location)
if (path_host == "" || length(path_host) == 0 || is.na(path_host)) {
path_host &lt;-
"https://github.com/hfang-bristol/RDataCentre/blob/master/Portal"
}
load_remote &lt;- paste(path_host, "/", RData, ".RData",
sep = "")
load_local1 &lt;- file.path(path_host, paste("data/", RData,
".RData", sep = ""))
load_local2 &lt;- file.path(path_host, paste(RData, ".RData",
sep = ""))
load_package &lt;- RData
if (1) {
RData_local &lt;- c(load_local1, load_local2)
load_flag &lt;- sapply(RData_local, function(x) {
if (.Platform$OS.type == "windows")
x &lt;- gsub("/", "\\", x)
ifelse(file.exists(x), TRUE, FALSE)
})
if (sum(load_flag) == 0) {
flag_failed &lt;- F
if (length(grep("^https", load_remote, perl = T))) {
if (length(grep("github", load_remote, perl = T))) {
load_remote &lt;- paste(load_remote, "?raw=true",
sep = "")
}
res &lt;- my_https_downloader(load_remote, mode = "wb")
if (res$flag == F) {
flag_failed &lt;- T
}
else {
eval(parse(text = paste(RData, " &lt;- res$RData",
sep = "")))
}
}
else {
res &lt;- my_https_downloader(load_remote, mode = "wb")
if (res$flag == F) {
flag_failed &lt;- T
}
else {
eval(parse(text = paste(RData, " &lt;- res$RData",
sep = "")))
}
}
if (flag_failed) {
load_remotes &lt;-
c(paste("https://github.com/hfang-bristol/RDataCentre/blob/master/Portal/",
RData, ".RData?raw=true", sep = ""),
paste("http://galahad.well.ox.ac.uk/bigdata/",
RData, ".RData", sep = ""),
paste("http://galahad.well.ox.ac.uk/bigdata/",
RData, ".RData", sep = ""))
for (i in 1:length(load_remotes)) {
load_remote &lt;- load_remotes[i]
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Attempt to download from %s (at %s)",
load_remote, as.character(now)), appendLF = T)
}
res &lt;- my_https_downloader(load_remote, mode = "wb")
if (res$flag == T) {
break
}
}
if (res$flag == F) {
warnings("Built-in Rdata files cannot be loaded. Please check your
internet connection or their location in your local machine.\n")
eval(parse(text = paste(RData, " &lt;- res$RData",
sep = "")))
}
else {
eval(parse(text = paste(RData, " &lt;- res$RData",
sep = "")))
}
}
load_RData &lt;- load_remote
out &lt;- base::get(RData)
}
else {
load_RData &lt;- RData_local[load_flag]
out &lt;- base::get(load(load_RData))
}
}
else {
load_RData &lt;- sprintf("package 'XGR' version %s",
utils::packageVersion("XGR"))
out &lt;- base::get(RData)
}
}
if (verbose) {
now &lt;- Sys.time()
if (!is.null(out)) {
message(sprintf("'%s' (from %s) has been loaded into the working
environment (at %s)",
RData, load_RData, as.character(now)), appendLF = T)
}
else {
message(sprintf("'%s' CANNOT be loaded (at %s)",
RData, as.character(now)), appendLF = T)
}
}
endT &lt;- Sys.time()
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
if (verbose) {
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = TRUE)
message(paste(c("Runtime in total is: ", runTime, " secs\n"),
collapse = ""), appendLF = TRUE)
}
invisible(out)
}
</pre>


</body></html>
