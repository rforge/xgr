<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGR2xGeneAnno"><tr><td>xGR2xGeneAnno</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGR2xGeneAnno</h2>

<h3>Usage</h3>

<pre>
xGR2xGeneAnno(data, background = NULL, format = c("chr:start-end",
"data.frame", "bed", "GRanges"), build.conversion = c(NA,
"hg38.to.hg19", "hg18.to.hg19"), crosslink = c("genehancer",
"PCHiC_combined", "GTEx_V6p_combined", "nearby"), crosslink.customised
= NULL, crosslink.top = NULL, nearby.distance.max = 50000,
nearby.decay.kernel = c("rapid", "slow", "linear", "constant"),
nearby.decay.exponent = 2, ontology = NA, size.range = c(10, 2000),
min.overlap = 5, which.distance = NULL, test = c("hypergeo", "fisher",
"binomial"), background.annotatable.only = NULL, p.tail = c("one-tail",
"two-tails"), p.adjust.method = c("BH", "BY", "bonferroni", "holm",
"hochberg", "hommel"), ontology.algorithm = c("none", "pc", "elim",
"lea"), elim.pvalue = 0.01, lea.depth = 2, path.mode = c("all_paths",
"shortest_paths", "all_shortest_paths"), true.path.rule = F,
out.evidence = T, out.evidence.plot = F, verbose = T, silent = F,
RData.location = "http://galahad.well.ox.ac.uk/bigdata", guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>format</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>build.conversion</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>crosslink</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>crosslink.customised</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>crosslink.top</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>nearby.distance.max</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>nearby.decay.kernel</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>nearby.decay.exponent</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontology</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>size.range</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>min.overlap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>which.distance</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>test</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.annotatable.only</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.tail</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.adjust.method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontology.algorithm</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>elim.pvalue</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>lea.depth</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>true.path.rule</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>out.evidence</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>out.evidence.plot</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>silent</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, background = NULL, format = c("chr:start-end",
"data.frame", "bed", "GRanges"), build.conversion = c(NA,
"hg38.to.hg19", "hg18.to.hg19"), crosslink = c("genehancer",
"PCHiC_combined", "GTEx_V6p_combined", "nearby"), crosslink.customised
= NULL,
crosslink.top = NULL, nearby.distance.max = 50000, nearby.decay.kernel
= c("rapid",
"slow", "linear", "constant"), nearby.decay.exponent = 2,
ontology = NA, size.range = c(10, 2000), min.overlap = 5,
which.distance = NULL, test = c("hypergeo", "fisher", "binomial"),
background.annotatable.only = NULL, p.tail = c("one-tail",
"two-tails"), p.adjust.method = c("BH", "BY", "bonferroni",
"holm", "hochberg", "hommel"), ontology.algorithm = c("none",
"pc", "elim", "lea"), elim.pvalue = 0.01, lea.depth = 2,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = F, out.evidence = T, out.evidence.plot = F,
verbose = T, silent = F, RData.location =
"http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
startT &lt;- Sys.time()
if (!silent) {
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = TRUE)
message("", appendLF = TRUE)
}
else {
verbose &lt;- FALSE
}
format &lt;- match.arg(format)
build.conversion &lt;- match.arg(build.conversion)
nearby.decay.kernel &lt;- match.arg(nearby.decay.kernel)
test &lt;- match.arg(test)
p.tail &lt;- match.arg(p.tail)
p.adjust.method &lt;- match.arg(p.adjust.method)
ontology.algorithm &lt;- match.arg(ontology.algorithm)
path.mode &lt;- match.arg(path.mode)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("First, import the data/background formatted as '%s'
(%s) ...",
format, as.character(now)), appendLF = T)
}
dGR &lt;- xGR(data = data, format = format, build.conversion =
build.conversion,
verbose = verbose, RData.location = RData.location, guid = guid)
bGR &lt;- xGR(data = background, format = format, build.conversion =
build.conversion,
verbose = verbose, RData.location = RData.location, guid = guid)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Second, define crosslinked genes based on '%s' (%s)
...",
crosslink, as.character(now)), appendLF = T)
}
df_xGenes_data &lt;- xGR2xGenes(data = dGR, format = "GRanges",
crosslink = crosslink, crosslink.customised = crosslink.customised,
cdf.function = "original", scoring = TRUE, scoring.scheme = "max",
scoring.rescale = F, nearby.distance.max = nearby.distance.max,
nearby.decay.kernel = nearby.decay.kernel, nearby.decay.exponent =
nearby.decay.exponent,
verbose = verbose, silent = !verbose, RData.location = RData.location,
guid = guid)
df_xGenes_background &lt;- xGR2xGenes(data = bGR, format = "GRanges",
crosslink = crosslink, crosslink.customised = crosslink.customised,
cdf.function = "original", scoring = TRUE, scoring.scheme = "max",
scoring.rescale = F, nearby.distance.max = nearby.distance.max,
nearby.decay.kernel = nearby.decay.kernel, nearby.decay.exponent =
nearby.decay.exponent,
verbose = verbose, silent = !verbose, RData.location = RData.location,
guid = guid)
Score &lt;- Gene &lt;- NULL
df_xGenes_data &lt;- df_xGenes_data %&gt;% dplyr::arrange(-Score)
if (is.null(crosslink.top)) {
crosslink.top &lt;- nrow(df_xGenes_data)
}
if (crosslink.top &gt; nrow(df_xGenes_data)) {
crosslink.top &lt;- nrow(df_xGenes_data)
}
crosslink.top &lt;- as.integer(crosslink.top)
crosslink.cutoff &lt;- df_xGenes_data[crosslink.top, "Score"]
dGR_genes &lt;- df_xGenes_data$Gene[df_xGenes_data$Score &gt;=
crosslink.cutoff]
if (!is.null(df_xGenes_background)) {
bGR_genes &lt;- (df_xGenes_background %&gt;% dplyr::arrange(-Score))$Gene
}
else {
bGR_genes &lt;- NULL
}
if (verbose) {
if (is.null(bGR_genes)) {
message(sprintf("\t%d (out of %d crosslinked genes) are used.",
length(dGR_genes), nrow(df_xGenes_data), as.character(Sys.time())),
appendLF = T)
}
else {
message(sprintf("\t%d (out of %d crosslinked genes) and %d
background genes are used.",
length(dGR_genes), nrow(df_xGenes_data), length(bGR_genes),
as.character(Sys.time())), appendLF = T)
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\n#######################################################",
appendLF = T))
message(sprintf("'xEnricherGenes' is being called (%s):",
as.character(now)), appendLF = T)
message(sprintf("#######################################################",
appendLF = T))
}
eTerm &lt;- xEnricherGenes(data = dGR_genes, background = bGR_genes,
ontology = ontology, size.range = size.range, min.overlap =
min.overlap,
which.distance = which.distance, test = test,
background.annotatable.only = background.annotatable.only,
p.tail = p.tail, p.adjust.method = p.adjust.method, ontology.algorithm
= ontology.algorithm,
elim.pvalue = elim.pvalue, lea.depth = lea.depth, path.mode =
path.mode,
true.path.rule = true.path.rule, verbose = verbose, silent = !verbose,
RData.location = RData.location, guid = guid)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("#######################################################",
appendLF = T))
message(sprintf("'xEnricherGenes' has been finished (%s)!",
as.character(now)), appendLF = T)
message(sprintf("#######################################################\n",
appendLF = T))
}
if (!is.null(eTerm)) {
ind &lt;- match(df_xGenes_data$Gene, dGR_genes)
eTerm$crosslink &lt;- df_xGenes_data[!is.na(ind), c("Gene",
"Score", "Pval")]
if (out.evidence) {
df_evidence &lt;- xGR2xGenes(data = dGR, format = "GRanges",
crosslink = crosslink, crosslink.customised = crosslink.customised,
cdf.function = "original", scoring = FALSE, scoring.scheme = "max",
scoring.rescale = F, nearby.distance.max = nearby.distance.max,
nearby.decay.kernel = nearby.decay.kernel, nearby.decay.exponent =
nearby.decay.exponent,
verbose = verbose, silent = !verbose, RData.location = RData.location,
guid = guid)
ind &lt;- match(df_evidence$Gene, dGR_genes)
evidence &lt;- df_evidence[!is.na(ind), c("GR", "Gene",
"Score")]
eTerm$evidence &lt;- evidence
if (out.evidence.plot) {
Gene &lt;- Score &lt;- NULL
mat_evidence &lt;- tidyr::spread(evidence, key = Gene,
value = Score)
mat &lt;- mat_evidence[, -1]
rownames(mat) &lt;- mat_evidence[, 1]
ind &lt;- xGRsort(rownames(mat))
mat &lt;- mat[ind, ]
rowsep &lt;- xGRsep(rownames(mat))
rowsep &lt;- nrow(mat) - rowsep
if (ncol(mat) &gt;= 0) {
reorder &lt;- "none"
}
else {
reorder &lt;- "col"
}
gp_evidence &lt;- xHeatmap(mat, reorder = reorder,
colormap = "spectral", ncolors = 64, barwidth = 0.4,
x.rotate = 90, shape = 19, size = 2, x.text.size = 6,
y.text.size = 6, na.color = "transparent")
gp_evidence &lt;- gp_evidence + theme(legend.title = element_text(size =
8),
legend.position = "left") + scale_y_discrete(position = "right")
gp_evidence &lt;- gp_evidence + geom_hline(yintercept = rowsep +
0.5, color = "grey90", size = 0.5)
eTerm$gp_evidence &lt;- gp_evidence
}
}
}
endT &lt;- Sys.time()
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
if (!silent) {
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = TRUE)
message(paste(c("Runtime in total (xGR2xGeneAnno): ",
runTime, " secs\n"), collapse = ""), appendLF = TRUE)
}
invisible(eTerm)
}
</pre>


</body></html>
