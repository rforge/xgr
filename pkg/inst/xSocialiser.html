<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xSocialiser"><tr><td>xSocialiser</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xSocialiser</h2>

<h3>Usage</h3>

<pre>
xSocialiser(data, annotation, g, measure = c("BM.average", "BM.max",
"BM.complete", "average", "max"), method.term = c("Resnik", "Lin",
"Schlicker", "Jiang", "Pesquita"), rescale = TRUE, force = TRUE, fast =
TRUE, parallel = TRUE, multicores = NULL, path.mode = c("all_paths",
"shortest_paths", "all_shortest_paths"), true.path.rule = TRUE, verbose
= T)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>annotation</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>g</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>measure</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>method.term</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>rescale</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>force</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>fast</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>multicores</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>true.path.rule</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, annotation, g, measure = c("BM.average", "BM.max",
"BM.complete", "average", "max"), method.term = c("Resnik",
"Lin", "Schlicker", "Jiang", "Pesquita"), rescale = TRUE,
force = TRUE, fast = TRUE, parallel = TRUE, multicores = NULL,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = TRUE, verbose = T)
{
measure &lt;- match.arg(measure)
method.term &lt;- match.arg(method.term)
path.mode &lt;- match.arg(path.mode)
if (class(annotation) == "GS") {
originAnnos &lt;- annotation$gs
}
else if (class(annotation) == "list") {
originAnnos &lt;- annotation
}
else if (class(annotation) == "dgCMatrix") {
D &lt;- annotation
originAnnos &lt;- sapply(1:ncol(D), function(j) {
names(which(D[, j] != 0))
})
names(originAnnos) &lt;- colnames(annotation)
}
else {
stop("The input annotation must be either 'GS' or 'list' or 'dgCMatrix'
object.\n")
}
annotation &lt;- originAnnos
ig &lt;- g
if (class(ig) != "igraph") {
stop("The function must apply to the 'igraph' object.\n")
}
else {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("First, generate a subgraph induced (via '%s' mode) by
the annotation data (%s) ...",
path.mode, as.character(now)), appendLF = T)
}
ig &lt;- xDAGanno(g = ig, annotation = annotation, path.mode = path.mode,
true.path.rule = true.path.rule, verbose = verbose)
}
anno &lt;- V(ig)$anno
allSNPs &lt;- sort(unique(unlist(anno)))
SNPs &lt;- data[!is.na(data)]
if (is.null(SNPs) || is.na(SNPs)) {
}
else {
flag &lt;- SNPs %in% allSNPs
if (sum(flag) != 0) {
SNPs &lt;- SNPs[flag]
}
else {
SNPs &lt;- SNPs[flag]
}
}
if (length(SNPs) &lt;= 1 || is.na(SNPs)) {
res &lt;- NULL
warning("The function returns NULL as no similarity is found at
all.\n")
return(res)
}
allterms &lt;- 1:length(anno)
sGT &lt;- Matrix::Matrix(0, nrow = length(SNPs), ncol = length(allterms),
sparse = T)
for (j in 1:length(allterms)) {
ind &lt;- match(anno[[j]], SNPs)
flag &lt;- ind[!is.na(ind)]
if (length(flag) != 0) {
sGT[flag, j] &lt;- 1
}
}
colnames(sGT) &lt;- V(ig)$name
rownames(sGT) &lt;- SNPs
if (verbose) {
message(sprintf("\tthere are %d inputs amongst %d annotatable",
length(SNPs), length(allSNPs)), appendLF = T)
}
SNPs2terms &lt;- lapply(1:length(SNPs), function(x) {
res &lt;- names(which(sGT[x, ] == 1))
if (force) {
subg &lt;- dnet::dDAGinduce(ig, nodes_query = res, path.mode =
"all_paths")
res &lt;- dnet::dDAGtip(subg)
}
return(res)
})
names(SNPs2terms) &lt;- SNPs
terms &lt;- unique(unlist(SNPs2terms))
SNPs2terms_index &lt;- lapply(SNPs2terms, function(x) {
match(x, terms)
})
progress_indicate &lt;- function(i, B, step, flag = F) {
if (i%%ceiling(B/step) == 0 | i == B | i == 1) {
if (flag &amp; verbose) {
message(sprintf("\t%d out of %d (%s)", i, B,
as.character(Sys.time())), appendLF = T)
}
}
}
if (verbose) {
now &lt;- Sys.time()
if (force) {
message(sprintf("Next, pre-compute semantic similarity between %d
terms (forced to be the most specific for each gene/SNP) using '%s'
method (%s)...",
length(terms), method.term, as.character(now)),
appendLF = T)
}
else {
message(sprintf("Next, pre-compute semantic similarity between %d
terms using '%s' method (%s)...",
length(terms), method.term, as.character(now)),
appendLF = T)
}
}
sim.term &lt;- suppressMessages(xDAGsim(ig, terms = terms, method.term =
method.term,
fast = fast, parallel = parallel, multicores = multicores,
verbose = T))
if (class(sim.term) == "igraph") {
sim.term &lt;- xConverter(sim.term, from = "igraph", to = "dgCMatrix",
verbose = F)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Last, calculate pair-wise semantic similarity between
%d genes/SNPs using '%s' measure (%s)...",
length(SNPs), measure, as.character(now)), appendLF = T)
}
num_SNPs &lt;- length(SNPs2terms)
flag_parallel &lt;- F
if (parallel == TRUE) {
flag_parallel &lt;- xCheckParallel(multicores = multicores,
verbose = verbose)
if (flag_parallel) {
if (measure == "average") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:(num_SNPs -
1), .inorder = T, .combine = rbind), {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
fast &lt;- T
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
mean(sim12[, which(new_ind_js == k)])
})
x &lt;- rep(0, num_SNPs)
x[js] &lt;- res
x
}
})
}
else if (measure == "max") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:(num_SNPs -
1), .inorder = T, .combine = rbind), {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
fast &lt;- T
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
max(sim12[, which(new_ind_js == k)])
})
x &lt;- rep(0, num_SNPs)
x[js] &lt;- res
x
}
})
}
else if (measure == "BM.average") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:(num_SNPs -
1), .inorder = T, .combine = rbind), {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
fast &lt;- T
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
x &lt;- as.matrix(sim12[, which(new_ind_js ==
k)])
0.5 * (mean(apply(x, 1, max)) + mean(apply(x,
2, max)))
})
x &lt;- rep(0, num_SNPs)
x[js] &lt;- res
x
}
})
}
else if (measure == "BM.max") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:(num_SNPs -
1), .inorder = T, .combine = rbind), {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
fast &lt;- T
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
x &lt;- as.matrix(sim12[, which(new_ind_js ==
k)])
max(mean(apply(x, 1, max)), mean(apply(x,
2, max)))
})
x &lt;- rep(0, num_SNPs)
x[js] &lt;- res
x
}
})
}
else if (measure == "BM.complete") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:(num_SNPs -
1), .inorder = T, .combine = rbind), {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
fast &lt;- T
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
x &lt;- as.matrix(sim12[, which(new_ind_js ==
k)])
min(c(apply(x, 1, max), apply(x, 2, max)))
})
x &lt;- rep(0, num_SNPs)
x[js] &lt;- res
x
}
})
}
sim &lt;- rbind(sim, rep(0, num_SNPs))
sim &lt;- sim + Matrix::t(sim)
sim &lt;- Matrix::Matrix(sim, sparse = T)
}
}
if (flag_parallel == F) {
sim &lt;- Matrix::Matrix(0, nrow = length(SNPs), ncol = length(SNPs),
sparse = T)
if (measure == "average") {
for (i in 1:(num_SNPs - 1)) {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
mean(sim12[, which(new_ind_js == k)])
})
sim[i, js] &lt;- res
}
else {
for (j in (i + 1):num_SNPs) {
ind2 &lt;- SNPs2terms_index[[j]]
sim12 &lt;- as.matrix(sim.term[ind1, ind2])
sim[i, j] &lt;- mean(sim12)
}
}
}
}
else if (measure == "max") {
for (i in 1:(num_SNPs - 1)) {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
max(sim12[, which(new_ind_js == k)])
})
sim[i, js] &lt;- res
}
else {
for (j in (i + 1):num_SNPs) {
ind2 &lt;- SNPs2terms_index[[j]]
sim12 &lt;- as.matrix(sim.term[ind1, ind2])
sim[i, j] &lt;- max(sim12)
}
}
}
}
else if (measure == "BM.average") {
for (i in 1:(num_SNPs - 1)) {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
x &lt;- as.matrix(sim12[, which(new_ind_js ==
k)])
0.5 * (mean(apply(x, 1, max)) + mean(apply(x,
2, max)))
})
sim[i, js] &lt;- res
}
else {
for (j in (i + 1):num_SNPs) {
ind2 &lt;- SNPs2terms_index[[j]]
sim12 &lt;- as.matrix(sim.term[ind1, ind2])
sim[i, j] &lt;- 0.5 * (mean(apply(sim12, 1,
max)) + mean(apply(sim12, 2, max)))
}
}
}
}
else if (measure == "BM.max") {
for (i in 1:(num_SNPs - 1)) {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
x &lt;- as.matrix(sim12[, which(new_ind_js ==
k)])
max(mean(apply(x, 1, max)), mean(apply(x,
2, max)))
})
sim[i, js] &lt;- res
}
else {
for (j in (i + 1):num_SNPs) {
ind2 &lt;- SNPs2terms_index[[j]]
sim12 &lt;- as.matrix(sim.term[ind1, ind2])
sim[i, j] &lt;- max(mean(apply(sim12, 1, max)),
mean(apply(sim12, 2, max)))
}
}
}
}
else if (measure == "BM.complete") {
for (i in 1:(num_SNPs - 1)) {
ind1 &lt;- SNPs2terms_index[[i]]
progress_indicate(i, num_SNPs, 10, flag = T)
if (fast) {
js &lt;- (i + 1):num_SNPs
ind_js &lt;- SNPs2terms_index[js]
sim12 &lt;- matrix(sim.term[ind1, unlist(ind_js)],
nrow = length(ind1))
new_ind_js &lt;- rep(1:length(ind_js), sapply(ind_js,
length))
res &lt;- sapply(1:length(ind_js), function(k) {
x &lt;- as.matrix(sim12[, which(new_ind_js ==
k)])
min(c(apply(x, 1, max), apply(x, 2, max)))
})
sim[i, js] &lt;- res
}
else {
for (j in (i + 1):num_SNPs) {
ind2 &lt;- SNPs2terms_index[[j]]
sim12 &lt;- as.matrix(sim.term[ind1, ind2])
sim[i, j] &lt;- min(c(apply(sim12, 1, max),
apply(sim12, 2, max)))
}
}
}
}
sim &lt;- sim + Matrix::t(sim)
}
rownames(sim) &lt;- colnames(sim) &lt;- SNPs
sim[as.matrix(is.na(sim))] &lt;- 0
if (rescale) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Also rescale similarity into the [0,1] range (%s)",
as.character(now)), appendLF = T)
}
d_min &lt;- min(sim)
d_max &lt;- max(sim)
sim &lt;- apply(sim, 2, function(x) {
(x - d_min)/(d_max - d_min)
})
sim &lt;- Matrix::Matrix(sim, sparse = T)
}
if (class(sim) == "dgCMatrix" | class(sim) == "dsCMatrix") {
res &lt;- xConverter(sim, from = "dgCMatrix", to = "igraph",
verbose = F)
if (class(res) == "igraph") {
if (!is.null(E(res)$weight)) {
E(res)$weight &lt;- as.numeric(E(res)$weight)
}
}
res$dag &lt;- ig
}
if (ecount(res) == 0) {
res &lt;- NULL
warning("The function returns NULL as no similarity is found at
all.\n")
}
invisible(res)
}
</pre>


</body></html>
