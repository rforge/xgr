<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGRviaGenomicAnno"><tr><td>xGRviaGenomicAnno</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGRviaGenomicAnno</h2>

<h3>Usage</h3>

<pre>
xGRviaGenomicAnno(data.file, annotation.file = NULL, background.file =
NULL, format.file = c("data.frame", "bed", "chr:start-end", "GRanges"),
build.conversion = c(NA, "hg38.to.hg19", "hg18.to.hg19"), resolution =
c("bases", "regions", "hybrid"), background.annotatable.only = T,
p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH", "BY",
"bonferroni", "holm", "hochberg", "hommel"), GR.annotation = NA,
verbose = T, RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>annotation.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>format.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>build.conversion</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>resolution</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.annotatable.only</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.tail</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.adjust.method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.annotation</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data.file, annotation.file = NULL, background.file = NULL,
format.file = c("data.frame", "bed", "chr:start-end", "GRanges"),
build.conversion = c(NA, "hg38.to.hg19", "hg18.to.hg19"),
resolution = c("bases", "regions", "hybrid"),
background.annotatable.only = T,
p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH",
"BY", "bonferroni", "holm", "hochberg", "hommel"), GR.annotation = NA,
verbose = T, RData.location = "http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
startT &lt;- Sys.time()
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = T)
message("", appendLF = T)
format.file &lt;- match.arg(format.file)
build.conversion &lt;- match.arg(build.conversion)
resolution &lt;- match.arg(resolution)
p.adjust.method &lt;- match.arg(p.adjust.method)
p.tail &lt;- match.arg(p.tail)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("First, import the files formatted as '%s' (%s) ...",
format.file, as.character(now)), appendLF = T)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the data file (%s) ...", as.character(now)),
appendLF = T)
}
if (is.matrix(data.file) | is.data.frame(data.file) | class(data.file)
==
"GRanges") {
data &lt;- data.file
}
else if (!is.null(data.file) &amp; any(!is.na(data.file))) {
if (length(data.file) == 1) {
data &lt;- utils::read.delim(file = data.file, header = F,
row.names = NULL, stringsAsFactors = F)
}
else {
data &lt;- data.file
}
}
else {
stop("The file 'data.file' must be provided!\n")
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the annotation file (%s) ...",
as.character(now)), appendLF = T)
}
if (is.matrix(annotation.file) | is.data.frame(annotation.file) |
class(annotation.file) == "list") {
annotation &lt;- annotation.file
}
else if (!is.null(annotation.file)) {
annotation &lt;- utils::read.delim(file = annotation.file,
header = F, row.names = NULL, stringsAsFactors = F)
}
else {
if (verbose) {
message("\t\tThe file 'annotation.file' is not provided, so built-in
RData will be used instead!")
}
annotation &lt;- NULL
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the background file (%s) ...",
as.character(now)), appendLF = T)
}
if (is.matrix(background.file) | is.data.frame(background.file) |
class(background.file) == "GRanges") {
background &lt;- background.file
}
else if (!is.null(background.file)) {
if (length(background.file) == 1) {
background &lt;- utils::read.delim(file = background.file,
header = F, row.names = NULL, stringsAsFactors = F)
background &lt;- unique(background[, 1])
}
else {
background &lt;- background.file
}
}
else {
background &lt;- NULL
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Second, construct GenomicRanges object (%s) ...",
as.character(now)), appendLF = T)
}
if (format.file == "data.frame") {
if (ncol(data) &gt;= 3) {
data &lt;- data
}
else if (ncol(data) == 2) {
data &lt;- cbind(data, data[, 2])
}
else {
stop("Your input 'data.file' is not as expected!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]), end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(annotation)) {
if (ncol(annotation) &gt;= 4) {
annotation &lt;- annotation
}
else {
stop("Your input 'annotation.file' is not as expected!\n")
}
anno_ls &lt;- split(x = annotation[, -4], f = annotation[,
4])
aGR &lt;- base::lapply(anno_ls, function(x) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(x[,
2])) &amp; !is.na(as.numeric(x[, 3]))))
x &lt;- x[ind, ]
gr &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(x[,
1]), ranges = IRanges::IRanges(start = as.numeric(x[,
2]), end = as.numeric(x[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(x))))
})
}
else {
aGRL &lt;- xDefineGenomicAnno(GR.annotation, verbose = verbose,
RData.location = RData.location, guid = guid)
aGR &lt;- lapply(aGRL, function(x) x)
}
if (!is.null(background)) {
if (ncol(background) &gt;= 3) {
background &lt;- background
}
else if (ncol(background) == 2) {
background &lt;- cbind(background, background[,
2])
}
else {
stop("Your input 'background.file' is not as expected!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]), end = as.numeric(background[, 3])), strand =
S4Vectors::Rle(rep("*",
nrow(background))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "chr:start-end") {
input &lt;- do.call(rbind, strsplit(data[, 1], ":|-"))
if (ncol(input) &gt;= 3) {
data &lt;- input
}
else if (ncol(input) == 2) {
data &lt;- cbind(input, input[, 2])
}
else {
stop("Your input 'data.file' does not meet the format
'chr:start-end'!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]), end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(annotation)) {
input &lt;- do.call(rbind, strsplit(annotation[, 1],
":|-"))
if (ncol(input) &gt;= 3) {
annotation &lt;- cbind(input[, 1:3], annotation[,
2])
}
else if (ncol(input) == 2) {
annotation &lt;- cbind(input[, c(1, 2, 2)], annotation[,
2])
}
else {
stop("Your input 'annotation.file' does not meet the format
'chr:start-end'!\n")
}
anno_ls &lt;- split(x = annotation[, -4], f = annotation[,
4])
aGR &lt;- base::lapply(anno_ls, function(x) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(x[,
2])) &amp; !is.na(as.numeric(x[, 3]))))
x &lt;- x[ind, ]
gr &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(x[,
1]), ranges = IRanges::IRanges(start = as.numeric(x[,
2]), end = as.numeric(x[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(x))))
})
}
else {
aGRL &lt;- xDefineGenomicAnno(GR.annotation, verbose = verbose,
RData.location = RData.location, guid = guid)
aGR &lt;- lapply(aGRL, function(x) x)
}
if (!is.null(background)) {
input &lt;- do.call(rbind, strsplit(background[, 1],
":|-"))
if (ncol(input) &gt;= 3) {
background &lt;- input
}
else if (ncol(input) == 2) {
background &lt;- cbind(input, input[, 2])
}
else {
stop("Your input 'background.file' does not meet the format
'chr:start-end'!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]), end = as.numeric(background[, 3])), strand =
S4Vectors::Rle(rep("*",
nrow(data))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "bed") {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]) + 1, end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(annotation)) {
anno_ls &lt;- split(x = annotation[, -4], f = annotation[,
4])
aGR &lt;- base::lapply(anno_ls, function(x) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(x[,
2])) &amp; !is.na(as.numeric(x[, 3]))))
x &lt;- x[ind, ]
gr &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(x[,
1]), ranges = IRanges::IRanges(start = as.numeric(x[,
2]) + 1, end = as.numeric(x[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(x))))
})
}
else {
aGRL &lt;- xDefineGenomicAnno(GR.annotation, verbose = verbose,
RData.location = RData.location, guid = guid)
aGR &lt;- lapply(aGRL, function(x) x)
}
if (!is.null(background)) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]) + 1, end = as.numeric(background[, 3])),
strand = S4Vectors::Rle(rep("*", nrow(data))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "GRanges") {
dGR &lt;- data
if (!is.null(annotation)) {
aGR &lt;- annotation
}
else {
aGRL &lt;- xDefineGenomicAnno(GR.annotation, verbose = verbose,
RData.location = RData.location, guid = guid)
aGR &lt;- lapply(aGRL, function(x) x)
}
if (!is.null(background)) {
bGR &lt;- background
}
else {
bGR &lt;- NULL
}
}
mergeOverlaps &lt;- function(qGR, sGR, maxgap = -1L, minoverlap = 0L) {
hits &lt;- as.matrix(as.data.frame(GenomicRanges::findOverlaps(query =
qGR,
subject = sGR, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = T)))
qhits &lt;- qGR[hits[, 1]]
shits &lt;- sGR[hits[, 2]]
oGR &lt;- IRanges::pintersect(qhits, shits, ignore.strand = T)
IRanges::reduce(oGR)
}
doBinomialTest &lt;- function(X, K, M, N, p.tail) {
N &lt;- max(N, M)
if (K == 0 || M == 0 || N == 0) {
p.value &lt;- 1
}
else {
if (p.tail == "one-tail") {
p.value &lt;- stats::pbinom(X, K, M/N, lower.tail = F,
log.p = F)
}
else {
if (X &gt;= K * M/N) {
p.value &lt;- stats::pbinom(X, K, M/N, lower.tail = F,
log.p = F)
}
else {
p.value &lt;- stats::pbinom(X, K, M/N, lower.tail = T,
log.p = F)
}
}
}
return(p.value)
}
if (!is.na(build.conversion)) {
if (verbose) {
message(sprintf("\tdata genomic regions: lifted over via genome build
conversion `%s`",
build.conversion), appendLF = T)
}
dGR &lt;- xLiftOver(data.file = dGR, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location,
guid = guid)
if (!is.null(annotation.file)) {
if (verbose) {
message(sprintf("\tannotation genomic regions: lifted over via genome
build conversion `%s`",
build.conversion), appendLF = T)
}
aGR &lt;- lapply(aGR, function(gr) {
xLiftOver(data.file = gr, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location,
guid = guid)
})
}
if (!is.null(bGR)) {
if (verbose) {
message(sprintf("\tbackground genomic regions: lifted over via genome
build conversion `%s`",
build.conversion), appendLF = T)
}
bGR &lt;- xLiftOver(data.file = bGR, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location,
guid = guid)
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Third, define the background (%s) ...",
as.character(now)), appendLF = T)
}
dGR_reduced &lt;- IRanges::reduce(dGR)
aGR_reduced &lt;- base::lapply(aGR, function(x) {
IRanges::reduce(x)
})
if (is.null(bGR)) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tall annotatable regions (by default) are used as the
background (%s) ...",
as.character(now)), appendLF = T)
}
aGRL &lt;- GenomicRanges::GRangesList(aGR_reduced)
bGR_reduced &lt;- IRanges::reduce(BiocGenerics::unlist(aGRL))
}
else {
bGR_reduced &lt;- IRanges::reduce(bGR)
aGR_reduced &lt;- base::lapply(aGR_reduced, function(gr) {
mergeOverlaps(qGR = gr, sGR = bGR_reduced, maxgap = -1L,
minoverlap = 0L)
})
if (background.annotatable.only) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe given background regions but restricted to the
annotatable are used as the background (%s) ...",
as.character(now)), appendLF = T)
}
aGRL &lt;- GenomicRanges::GRangesList(aGR_reduced)
bGR_reduced &lt;- IRanges::reduce(BiocGenerics::unlist(aGRL))
}
else {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe given background regions are used as the
background (%s) ...",
as.character(now)), appendLF = T)
}
}
}
dGR_reduced &lt;- mergeOverlaps(qGR = dGR_reduced, sGR = bGR_reduced,
maxgap = -1L, minoverlap = 0L)
oGR_reduced &lt;- base::lapply(aGR_reduced, function(gr) {
mergeOverlaps(qGR = gr, sGR = dGR_reduced, maxgap = -1L,
minoverlap = 0L)
})
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Forth, perform enrichment analysis at '%s' resolution
with '%s' p-values (%s) ...",
resolution, p.tail, as.character(now)), appendLF = T)
}
if (resolution == "bases") {
data_nBases &lt;- sum(as.numeric(IRanges::width(dGR_reduced)))
overlap_nBases &lt;- base::sapply(oGR_reduced, function(gr) {
sum(as.numeric(IRanges::width(gr)))
})
annotation_nBases &lt;- base::sapply(aGR_reduced, function(gr) {
sum(as.numeric(IRanges::width(gr)))
})
background_nBases &lt;- sum(as.numeric(IRanges::width(bGR_reduced)))
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe number of bases: data (%d)",
data_nBases), appendLF = T)
message(sprintf("\tthe number of annotations: %d",
length(annotation_nBases)), appendLF = T)
}
}
else if (resolution == "regions") {
data_nBases &lt;- length(dGR_reduced)
overlap_nBases &lt;- base::sapply(oGR_reduced, length)
annotation_nBases &lt;- base::sapply(aGR_reduced, length)
background_nBases &lt;- max(length(bGR_reduced), max(annotation_nBases))
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe number of regions: data (%d)",
data_nBases), appendLF = T)
message(sprintf("\tthe number of annotations: %d",
length(annotation_nBases)), appendLF = T)
}
}
else if (resolution == "hybrid") {
data_nBases &lt;- length(dGR_reduced)
overlap_nBases &lt;- base::sapply(oGR_reduced, length)
annotation_nBases &lt;- base::sapply(aGR_reduced, function(gr) {
sum(as.numeric(IRanges::width(gr)))
})
background_nBases &lt;- sum(as.numeric(IRanges::width(bGR_reduced)))
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe number of regions: data (%d)",
data_nBases), appendLF = T)
message(sprintf("\tthe number of annotations: %d",
length(annotation_nBases)), appendLF = T)
}
}
res_ls &lt;- base::lapply(1:length(overlap_nBases), function(i) {
X &lt;- as.numeric(overlap_nBases[i])
K &lt;- data_nBases
M &lt;- as.numeric(annotation_nBases[i])
N &lt;- background_nBases
x.exp &lt;- K * M/N
var.exp &lt;- K * M/N * (N - M)/N * (N - K)/(N - 1)
if (is.na(var.exp)) {
z.score &lt;- 0
}
else {
if (var.exp != 0) {
suppressWarnings(z.score &lt;- (X - x.exp)/sqrt(var.exp))
}
else {
z.score &lt;- 0
}
}
if (is.na(z.score)) {
z.score &lt;- 0
}
p.value &lt;- doBinomialTest(X, K, M, N, p.tail)
if (all(resolution %in% c("bases", "regions"))) {
cTab &lt;- matrix(c(X, K - X, M - X, N - M - K + X),
nrow = 2, dimnames = list(c("anno", "notAnno"),
c("group", "notGroup")))
if (class(suppressWarnings(try(res &lt;- stats::fisher.test(cTab),
T))) == "try-error") {
or &lt;- CIl &lt;- CIu &lt;- NA
}
else {
res &lt;- stats::fisher.test(cTab)
or &lt;- as.vector(res$estimate)
CIl &lt;- as.vector(res$conf.int)[1]
CIu &lt;- as.vector(res$conf.int)[2]
}
}
else {
or &lt;- CIl &lt;- CIu &lt;- NA
}
c(X, K, M, N, X/K, M/N, (X/K)/(M/N), z.score, p.value,
or, CIl, CIu)
})
res_df &lt;- do.call(rbind, res_ls)
enrichment_df &lt;- data.frame(names(overlap_nBases), res_df,
stringsAsFactors = F)
colnames(enrichment_df) &lt;- c("name", "nOverlap", "nData",
"nAnno", "nBG", "obsProb", "expProb", "fc", "zscore",
"pvalue", "or", "CIl", "CIu")
p.adjust.method = c("BH", "BY", "bonferroni", "holm", "hochberg",
"hommel")[1]
pvals &lt;- enrichment_df$pvalue
adjpvals &lt;- stats::p.adjust(pvals, method = p.adjust.method)
enrichment_df$adjp &lt;- adjpvals
enrichment_df$zscore &lt;- signif(enrichment_df$zscore, digits = 3)
pvals &lt;- enrichment_df$pvalue
adjpvals &lt;- enrichment_df$adjp
pvals &lt;- signif(pvals, digits = 2)
adjpvals &lt;- signif(adjpvals, digits = 2)
pvals &lt;- base::sapply(pvals, function(x) {
if (x &lt; 0.1 &amp; x != 0) {
as.numeric(format(x, scientific = T))
}
else {
x
}
})
adjpvals &lt;- base::sapply(adjpvals, function(x) {
if (x &lt; 0.1 &amp; x != 0) {
as.numeric(format(x, scientific = T))
}
else {
x
}
})
enrichment_df$pvalue &lt;- pvals
enrichment_df$adjp &lt;- adjpvals
endT &lt;- Sys.time()
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = T)
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
message(paste(c("Runtime in total is: ", runTime, " secs\n"),
collapse = ""), appendLF = T)
res_df &lt;- enrichment_df[, c("name", "nAnno", "nOverlap",
"fc", "zscore", "pvalue", "adjp", "or", "CIl", "CIu",
"expProb", "obsProb")]
eTerm &lt;- xEnrichViewer(res_df, top_num = nrow(res_df), sortBy =
"zscore")
invisible(eTerm)
}
</pre>


</body></html>
