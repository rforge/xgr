<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xDAGsim"><tr><td>xDAGsim</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xDAGsim</h2>

<h3>Usage</h3>

<pre>
xDAGsim(g, terms = NULL, method.term = c("Resnik", "Lin", "Schlicker",
"Jiang", "Pesquita"), fast = T, parallel = TRUE, multicores = NULL,
verbose = T)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>g</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>terms</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>method.term</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>fast</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>multicores</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (g, terms = NULL, method.term = c("Resnik", "Lin",
"Schlicker",
"Jiang", "Pesquita"), fast = T, parallel = TRUE, multicores = NULL,
verbose = T)
{
method.term &lt;- match.arg(method.term)
ig &lt;- g
if (class(ig) != "igraph") {
stop("The function must apply to the 'igraph' object.\n")
}
if (is.null(V(ig)$anno) | is.null(V(ig)$IC)) {
stop("The function requires that input graph has already contained
annotation data.  Please first run 'xDAGanno'.\n")
}
IC &lt;- V(ig)$IC
names(IC) &lt;- V(ig)$name
terms &lt;- terms[!is.na(terms)]
if (is.null(terms) || is.na(terms)) {
terms &lt;- V(ig)$name
}
else {
flag &lt;- terms %in% V(ig)$name
if (sum(flag) != 0) {
terms &lt;- terms[flag]
}
else {
terms &lt;- V(ig)$name
}
}
progress_indicate &lt;- function(i, B, step, flag = F) {
if (i%%ceiling(B/step) == 0 | i == B | i == 1) {
if (flag &amp; verbose) {
message(sprintf("\t%d out of %d (%s)", i, B,
as.character(Sys.time())), appendLF = T)
}
}
}
num_terms &lt;- length(terms)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Calculate semantic similarity between %d terms using
'%s' method (%s)...",
num_terms, method.term, as.character(now)), appendLF = T)
}
sCP &lt;- dnet::dDAGancestor(ig, term1 = terms, term2 = NULL,
verbose = T)
allterms &lt;- V(ig)$name
ind &lt;- match(terms, allterms)
flag_parallel &lt;- F
if (parallel == TRUE) {
flag_parallel &lt;- xCheckParallel(multicores = multicores,
verbose = verbose)
if (flag_parallel) {
if (method.term == "Resnik") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:num_terms,
.inorder = T, .combine = rbind), {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
fast &lt;- T
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i -
1
res &lt;- IC[mica_js]
x &lt;- rep(0, num_terms)
x[js] &lt;- res
x
}
})
}
else if (method.term == "Lin") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:num_terms,
.inorder = T, .combine = rbind), {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
fast &lt;- T
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i -
1
res &lt;- 2 * IC[mica_js]/(IC[ind[i]] + IC[ind[js]])
x &lt;- rep(0, num_terms)
x[js] &lt;- res
x
}
})
}
else if (method.term == "Schlicker") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:num_terms,
.inorder = T, .combine = rbind), {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
fast &lt;- T
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i -
1
res &lt;- (2 * IC[mica_js]/(IC[ind[i]] + IC[ind[js]])) *
(1 - 10^(-IC[mica_js]))
x &lt;- rep(0, num_terms)
x[js] &lt;- res
x
}
})
}
else if (method.term == "Jiang") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:num_terms,
.inorder = T, .combine = rbind), {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
fast &lt;- T
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i -
1
tmp &lt;- IC[ind[i]] + IC[ind[js]] - 2 * IC[mica_js]
tmp[tmp &gt; 1] &lt;- 1
res &lt;- 1 - tmp
x &lt;- rep(0, num_terms)
x[js] &lt;- res
x
}
})
}
else if (method.term == "Pesquita") {
i &lt;- 1
sim &lt;- foreach::`%dopar%`(foreach::foreach(i = 1:num_terms,
.inorder = T, .combine = rbind), {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
fast &lt;- T
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i -
1
allan_js_list &lt;- split(ancestor_js[, 2],
ancestor_js[, 1])
allan_union &lt;- sapply(allan_js_list, function(x) {
ux &lt;- base::union(x, ancestor_i)
sum(IC[ux])
})
allca_union &lt;- sapply(ca_js_list, function(x) {
sum(IC[x])
})
res &lt;- allca_union/allan_union
x &lt;- rep(0, num_terms)
x[js] &lt;- res
x
}
})
}
sim &lt;- sim + Matrix::t(sim)
sim &lt;- Matrix::Matrix(sim, sparse = T)
}
}
if (flag_parallel == F) {
sim &lt;- Matrix::Matrix(0, nrow = num_terms, ncol = num_terms,
sparse = T)
if (method.term == "Resnik") {
for (i in 1:num_terms) {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i - 1
res &lt;- IC[mica_js]
sim[i, js] &lt;- res
}
else {
for (j in i:num_terms) {
ancestor_j &lt;- which(sCP[j, ] == 1)
ancestors &lt;- intersect(ancestor_i, ancestor_j)
mica &lt;- ancestors[which.max(IC[ancestors])]
res &lt;- IC[mica]
sim[i, j] &lt;- res
}
}
}
}
else if (method.term == "Lin") {
for (i in 1:num_terms) {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i - 1
res &lt;- 2 * IC[mica_js]/(IC[ind[i]] + IC[ind[js]])
sim[i, js] &lt;- res
}
else {
for (j in i:num_terms) {
ancestor_j &lt;- which(sCP[j, ] == 1)
ancestors &lt;- intersect(ancestor_i, ancestor_j)
mica &lt;- ancestors[which.max(IC[ancestors])]
res &lt;- 2 * IC[mica]/(IC[ind[i]] + IC[ind[j]])
sim[i, j] &lt;- res
}
}
}
}
else if (method.term == "Schlicker") {
for (i in 1:num_terms) {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i - 1
res &lt;- (2 * IC[mica_js]/(IC[ind[i]] + IC[ind[js]])) *
(1 - 10^(-IC[mica_js]))
sim[i, js] &lt;- res
}
else {
for (j in i:num_terms) {
ancestor_j &lt;- which(sCP[j, ] == 1)
ancestors &lt;- intersect(ancestor_i, ancestor_j)
mica &lt;- ancestors[which.max(IC[ancestors])]
res &lt;- (2 * IC[mica]/(IC[ind[i]] + IC[ind[j]])) *
(1 - 10^(-IC[mica]))
sim[i, j] &lt;- res
}
}
}
}
else if (method.term == "Jiang") {
for (i in 1:num_terms) {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i - 1
tmp &lt;- IC[ind[i]] + IC[ind[js]] - 2 * IC[mica_js]
tmp[tmp &gt; 1] &lt;- 1
res &lt;- 1 - tmp
sim[i, js] &lt;- res
}
else {
for (j in i:num_terms) {
ancestor_j &lt;- which(sCP[j, ] == 1)
ancestors &lt;- intersect(ancestor_i, ancestor_j)
mica &lt;- ancestors[which.max(IC[ancestors])]
res &lt;- 1 - min(1, IC[ind[i]] + IC[ind[j]] -
2 * IC[mica])
sim[i, j] &lt;- res
}
}
}
}
else if (method.term == "Pesquita") {
for (i in 1:num_terms) {
ancestor_i &lt;- which(sCP[i, ] == 1)
progress_indicate(i, num_terms, 10, flag = T)
if (fast) {
mat &lt;- sCP[i:num_terms, ]
ancestor_js &lt;- which(matrix(mat == 1, nrow = num_terms -
i + 1), arr.ind = T)
flag &lt;- is.element(ancestor_js[, 2], ancestor_i)
ca_js &lt;- ancestor_js[flag, ]
ca_js_list &lt;- split(ca_js[, 2], ca_js[, 1])
mica_js &lt;- sapply(ca_js_list, function(x) {
x[which.max(IC[x])]
})
js &lt;- as.numeric(names(ca_js_list)) + i - 1
allan_js_list &lt;- split(ancestor_js[, 2], ancestor_js[,
1])
allan_union &lt;- sapply(allan_js_list, function(x) {
ux &lt;- base::union(x, ancestor_i)
sum(IC[ux])
})
allca_union &lt;- sapply(ca_js_list, function(x) {
sum(IC[x])
})
res &lt;- allca_union/allan_union
sim[i, js] &lt;- res
}
else {
for (j in i:num_terms) {
ancestor_j &lt;- which(sCP[j, ] == 1)
ancestors &lt;- intersect(ancestor_i, ancestor_j)
mica &lt;- ancestors[which.max(IC[ancestors])]
allancestors &lt;- base::union(ancestor_i, ancestor_j)
res &lt;- sum(IC[ancestors])/sum(IC[allancestors])
sim[i, j] &lt;- res
}
}
}
}
sim &lt;- sim + Matrix::t(sim)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Semantic similarity has been calculated (%s)!",
as.character(now)), appendLF = T)
}
rownames(sim) &lt;- colnames(sim) &lt;- terms
sim[as.matrix(is.na(sim))] &lt;- 0
if (class(sim) == "dgCMatrix") {
res &lt;- xConverter(sim, from = "dgCMatrix", to = "igraph",
verbose = verbose)
}
invisible(res)
}
</pre>


</body></html>
