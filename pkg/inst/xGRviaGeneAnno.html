<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGRviaGeneAnno"><tr><td>xGRviaGeneAnno</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGRviaGeneAnno</h2>

<h3>Usage</h3>

<pre>
xGRviaGeneAnno(data.file, background.file = NULL, format.file =
c("data.frame", "bed", "chr:start-end", "GRanges"), build.conversion =
c(NA, "hg38.to.hg19", "hg18.to.hg19"), gap.max = 0, GR.Gene =
c("UCSC_knownGene", "UCSC_knownCanonical"), ontology = NA, size.range =
c(10, 2000), min.overlap = 5, which.distance = NULL, test = c("fisher",
"hypergeo", "binomial"), background.annotatable.only = NULL, p.tail =
c("one-tail", "two-tails"), p.adjust.method = c("BH", "BY",
"bonferroni", "holm", "hochberg", "hommel"), ontology.algorithm =
c("none", "pc", "elim", "lea"), elim.pvalue = 0.01, lea.depth = 2,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = F, verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata", guid = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>format.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>build.conversion</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>gap.max</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.Gene</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontology</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>size.range</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>min.overlap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>which.distance</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>test</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.annotatable.only</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.tail</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.adjust.method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontology.algorithm</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>elim.pvalue</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>lea.depth</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>true.path.rule</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>guid</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data.file, background.file = NULL, format.file =
c("data.frame",
"bed", "chr:start-end", "GRanges"), build.conversion = c(NA,
"hg38.to.hg19", "hg18.to.hg19"), gap.max = 0, GR.Gene =
c("UCSC_knownGene",
"UCSC_knownCanonical"), ontology = NA, size.range = c(10,
2000), min.overlap = 5, which.distance = NULL, test = c("fisher",
"hypergeo", "binomial"), background.annotatable.only = NULL,
p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH",
"BY", "bonferroni", "holm", "hochberg", "hommel"), ontology.algorithm =
c("none",
"pc", "elim", "lea"), elim.pvalue = 0.01, lea.depth = 2,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = F, verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata",
guid = NULL)
{
startT &lt;- Sys.time()
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = T)
message("", appendLF = T)
format.file &lt;- match.arg(format.file)
build.conversion &lt;- match.arg(build.conversion)
test &lt;- match.arg(test)
p.tail &lt;- match.arg(p.tail)
p.adjust.method &lt;- match.arg(p.adjust.method)
ontology.algorithm &lt;- match.arg(ontology.algorithm)
path.mode &lt;- match.arg(path.mode)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("First, import the files formatted as '%s' (%s) ...",
format.file, as.character(now)), appendLF = T)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the data file (%s) ...", as.character(now)),
appendLF = T)
}
if (is.matrix(data.file) | is.data.frame(data.file) | class(data.file)
==
"GRanges") {
data &lt;- data.file
}
else if (!is.null(data.file) &amp; any(!is.na(data.file))) {
if (length(data.file) == 1) {
data &lt;- utils::read.delim(file = data.file, header = F,
row.names = NULL, stringsAsFactors = F)
}
else {
data &lt;- data.file
}
}
else {
stop("The file 'data.file' must be provided!\n")
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the background file (%s) ...",
as.character(now)), appendLF = T)
}
if (is.matrix(background.file) | is.data.frame(background.file) |
class(background.file) == "GRanges") {
background &lt;- background.file
}
else if (!is.null(background.file)) {
if (length(background.file) == 1) {
background &lt;- utils::read.delim(file = background.file,
header = F, row.names = NULL, stringsAsFactors = F)
background &lt;- unique(background[, 1])
}
else {
background &lt;- background.file
}
}
else {
background &lt;- NULL
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Second, construct GenomicRanges object (%s) ...",
as.character(now)), appendLF = T)
}
if (format.file == "data.frame") {
if (ncol(data) &gt;= 3) {
data &lt;- data
}
else if (ncol(data) == 2) {
data &lt;- cbind(data, data[, 2])
}
else {
stop("Your input 'data.file' is not as expected!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]), end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(background)) {
if (ncol(background) &gt;= 3) {
background &lt;- background
}
else if (ncol(background) == 2) {
background &lt;- cbind(background, background[,
2])
}
else {
stop("Your input 'background.file' is not as expected!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]), end = as.numeric(background[, 3])), strand =
S4Vectors::Rle(rep("*",
nrow(background))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "chr:start-end") {
if (is.null(dim(data))) {
input &lt;- do.call(rbind, strsplit(data, ":|-"))
}
else {
input &lt;- do.call(rbind, strsplit(data[, 1], ":|-"))
}
if (ncol(input) &gt;= 3) {
data &lt;- input
}
else if (ncol(input) == 2) {
data &lt;- cbind(input, input[, 2])
}
else {
stop("Your input 'data.file' does not meet the format
'chr:start-end'!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]), end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(background)) {
input &lt;- do.call(rbind, strsplit(background[, 1],
":|-"))
if (ncol(input) &gt;= 3) {
background &lt;- input
}
else if (ncol(input) == 2) {
background &lt;- cbind(input, input[, 2])
}
else {
stop("Your input 'background.file' does not meet the format
'chr:start-end'!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]), end = as.numeric(background[, 3])), strand =
S4Vectors::Rle(rep("*",
nrow(data))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "bed") {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]) + 1, end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(background)) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]) + 1, end = as.numeric(background[, 3])),
strand = S4Vectors::Rle(rep("*", nrow(data))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "GRanges") {
dGR &lt;- data
if (!is.null(background)) {
bGR &lt;- background
}
else {
bGR &lt;- NULL
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Third, define nearby genes of interest and genes as
the background (%s) ...",
as.character(now)), appendLF = T)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tload positional information for Genes (%s) ...",
as.character(now)), appendLF = T)
}
gr_Gene &lt;- xRDataLoader(GR.Gene[1], verbose = verbose, RData.location =
RData.location,
guid = guid)
if (is.null(gr_Gene)) {
GR.Gene &lt;- "UCSC_knownGene"
if (verbose) {
message(sprintf("\tinstead, %s will be used", GR.Gene),
appendLF = T)
}
gr_Gene &lt;- xRDataLoader(GR.Gene, verbose = verbose, RData.location =
RData.location,
guid = guid)
}
if (!is.na(build.conversion)) {
if (verbose) {
message(sprintf("\tdata genomic regions: lifted over via genome build
conversion `%s`",
build.conversion), appendLF = T)
}
dGR &lt;- xLiftOver(data.file = dGR, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location,
guid = guid)
}
maxgap &lt;- gap.max - 1
minoverlap &lt;- 0L
subject &lt;- gr_Gene
query &lt;- dGR
hits &lt;- as.matrix(as.data.frame(GenomicRanges::findOverlaps(query =
query,
subject = subject, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = T)))
dGR_genes &lt;- unique(names(gr_Gene[hits[, 2]]))
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\t%d nearby genes within %d distance are defined
(%s) ...",
length(dGR_genes), gap.max, as.character(now)), appendLF = T)
}
if (!is.null(bGR)) {
if (!is.na(build.conversion)) {
if (verbose) {
message(sprintf("\tbackground genomic regions: lifted over via genome
build conversion `%s`",
build.conversion), appendLF = T)
}
bGR &lt;- xLiftOver(data.file = bGR, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location,
guid = guid)
}
maxgap &lt;- gap.max - 1
minoverlap &lt;- 0L
subject &lt;- gr_Gene
query &lt;- bGR
hits &lt;- as.matrix(as.data.frame(GenomicRanges::findOverlaps(query =
query,
subject = subject, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = T)))
bGR_genes &lt;- unique(names(gr_Gene[hits[, 2]]))
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\t%d nearby genes with %d distance are defined as
the background (%s) ...",
length(bGR_genes), gap.max, as.character(now)),
appendLF = T)
}
}
else {
bGR_genes &lt;- NULL
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\n#######################################################",
appendLF = T))
message(sprintf("'xEnricherGenes' is being called (%s):",
as.character(now)), appendLF = T)
message(sprintf("#######################################################",
appendLF = T))
}
eTerm &lt;- xEnricherGenes(data = dGR_genes, background = bGR_genes,
ontology = ontology, size.range = size.range, min.overlap =
min.overlap,
which.distance = which.distance, test = test,
background.annotatable.only = background.annotatable.only,
p.tail = p.tail, p.adjust.method = p.adjust.method, ontology.algorithm
= ontology.algorithm,
elim.pvalue = elim.pvalue, lea.depth = lea.depth, path.mode =
path.mode,
true.path.rule = true.path.rule, verbose = verbose, RData.location =
RData.location,
guid = guid)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("#######################################################",
appendLF = T))
message(sprintf("'xEnricherGenes' has been finished (%s)!",
as.character(now)), appendLF = T)
message(sprintf("#######################################################\n",
appendLF = T))
}
endT &lt;- Sys.time()
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = T)
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
message(paste(c("Runtime in total is: ", runTime, " secs\n"),
collapse = ""), appendLF = T)
invisible(eTerm)
}
</pre>


</body></html>
