<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xDAGanno"><tr><td>xDAGanno</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xDAGanno</h2>

<h3>Usage</h3>

<pre>
xDAGanno(g, annotation, path.mode = c("all_paths", "shortest_paths",
"all_shortest_paths"), true.path.rule = TRUE, verbose = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>g</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>annotation</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>true.path.rule</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (g, annotation, path.mode = c("all_paths", "shortest_paths",
"all_shortest_paths"), true.path.rule = TRUE, verbose = TRUE)
{
path.mode &lt;- match.arg(path.mode)
ig &lt;- g
if (class(ig) != "igraph") {
stop("The function must apply to the 'igraph' object.\n")
}
if (class(annotation) == "GS") {
originAnnos &lt;- annotation$gs
}
else if (class(annotation) == "list") {
originAnnos &lt;- annotation
}
else if (class(annotation) == "dgCMatrix") {
D &lt;- annotation
originAnnos &lt;- sapply(1:ncol(D), function(j) {
names(which(D[, j] != 0))
})
names(originAnnos) &lt;- colnames(annotation)
}
else {
stop("The input annotation must be either 'GS' or 'list' or 'dgCMatrix'
object.\n")
}
if (is.list(originAnnos)) {
originNodes &lt;- names(originAnnos)
ind &lt;- match(originNodes, V(ig)$name)
nodes_mapped &lt;- originNodes[!is.na(ind)]
if (length(nodes_mapped) == 0) {
stop("The input annotation data do not contain terms matched to the
nodes/terms in the input graph.\n")
}
}
dag &lt;- dnet::dDAGinduce(ig, originNodes, path.mode = path.mode)
allNodes &lt;- V(dag)$name
node2domain.HoH &lt;- new.env(hash = T, parent = emptyenv())
lapply(allNodes, function(node) {
e &lt;- new.env(hash = T, parent = emptyenv())
if (node %in% originNodes) {
sapply(originAnnos[[node]], function(x) {
assign(as.character(x), "o", envir = e)
})
}
assign(node, e, envir = node2domain.HoH)
})
if (true.path.rule) {
level2node &lt;- dnet::dDAGlevel(dag, level.mode = "longest_path",
return.mode = "level2node")
level2node.Hash &lt;- list2env(level2node)
nLevels &lt;- length(level2node)
for (i in nLevels:1) {
currNodes &lt;- get(as.character(i), envir = level2node.Hash,
mode = "character")
adjNodesList &lt;- lapply(currNodes, function(node) {
neighs.in &lt;- igraph::neighborhood(dag, order = 1,
nodes = node, mode = "in")
setdiff(V(dag)[unlist(neighs.in)]$name, node)
})
names(adjNodesList) &lt;- currNodes
lapply(currNodes, function(node) {
domainsID &lt;- ls(get(node, envir = node2domain.HoH,
mode = "environment"))
lapply(adjNodesList[[node]], function(adjNode) {
adjEnv &lt;- get(adjNode, envir = node2domain.HoH,
mode = "environment")
sapply(domainsID, function(domainID) {
assign(domainID, "i", envir = adjEnv)
})
})
})
if (verbose) {
message(sprintf("\tAt level %d, there are %d nodes, and %d incoming
neighbors.",
i, length(currNodes), length(unique(unlist(adjNodesList)))),
appendLF = T)
}
}
}
node2domains &lt;- as.list(node2domain.HoH)[allNodes]
domain_annotation &lt;- lapply(node2domains, function(node) {
vec &lt;- unlist(as.list(node))
res &lt;- names(vec)
names(res) &lt;- vec
res
})
V(dag)$anno &lt;- domain_annotation
counts &lt;- sapply(V(dag)$anno, length)
IC &lt;- -1 * log10(counts/max(counts))
if (1) {
IC[is.infinite(IC)] &lt;- 0
}
V(dag)$IC &lt;- IC
return(dag)
}
</pre>


</body></html>
